<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[os]]></title>
      <url>/2017/10/10/os/</url>
      <content type="html"><![CDATA[<h2 id="Process-vs-Thread"><a href="#Process-vs-Thread" class="headerlink" title="Process vs Thread"></a>Process vs Thread</h2><p><strong>Process</strong>: An executing instance of a program is called a process.</p>
<p><strong>Thread</strong>: Thread is a lightweight thread(A thread is a subset of the process.)</p>
<p><strong>diff</strong>:</p>
<ul>
<li>Threads share the address space of the process that created it; processes have their own address space.</li>
<li>Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process.</li>
<li>Threads can directly communicate with other threads of its process; processes must use interprocess communication to communicate with sibling processes.</li>
<li>Threads have almost no overhead; processes have considerable overhead. context switch</li>
<li>New threads are easily created; new processes require duplication of the parent process.</li>
<li>Changes to the main thread (cancellation, priority change, etc.) may affect the behavior of the other threads of the process; changes to the parent process do not affect child processes.</li>
</ul>
<hr>
<h2 id="Different-type-of-thread"><a href="#Different-type-of-thread" class="headerlink" title="Different type of thread"></a>Different type of thread</h2><table>
<thead>
<tr>
<th>User level thread</th>
<th>Kernel level thread</th>
</tr>
</thead>
<tbody>
<tr>
<td>User thread are implemented by users</td>
<td>Kernel threads are implemented by OS </td>
</tr>
<tr>
<td>OS doesn’t recognized user level threads</td>
<td>Kernel threads are recognized by OS</td>
</tr>
<tr>
<td>implementation of User threads is easy</td>
<td>implementation of kernel thread is complicated</td>
</tr>
<tr>
<td>context switch time is less</td>
<td>context switch time is more</td>
</tr>
<tr>
<td>context switch requres no hardware support</td>
<td>hardware support is needed</td>
</tr>
<tr>
<td>if one user level thread perform blocking operation then entire process will be blocked</td>
<td>if one kernel thread perfrom blocking operation then another thread can continue execution</td>
</tr>
<tr>
<td>Example: JAVA thread, POSIX threads</td>
<td>windows solaris</td>
</tr>
</tbody>
</table>
<h2 id="context-switch"><a href="#context-switch" class="headerlink" title="context switch"></a>context switch</h2><p>a context switch is the process of storing and restoring the state (more specifically, the execution context) of a process or thread so that execution can be resumed from the same point at a later time. This enables multiple processes to share a single CPU and is an essential feature of a multitasking operating system<br><img src="https://upload.wikimedia.org/wikipedia/commons/0/04/Context_switch.png" alt="context Switch"></p>
<h2 id="interrupt-and-system-call"><a href="#interrupt-and-system-call" class="headerlink" title="interrupt and system call"></a>interrupt and system call</h2><p><strong>interrupt</strong>: an interrupt is a signal to the processor emitted by hardware or software indicating an event that needs immediate attention.</p>
<ul>
<li>haredware interrup<ul>
<li>keyboard, mouse</li>
</ul>
</li>
<li>software interrupt<ul>
<li>exception, divide by zero</li>
<li>services from device drivers</li>
</ul>
</li>
</ul>
<p><strong>system call</strong>: a system call is the programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on. This may include hardware-related services (for example, accessing a hard disk drive), creation and execution of new processes, and communication with integral kernel services such as process scheduling. System calls provide an essential interface between a process and the operating system.</p>
<p>when a process make a system call, which will cause an interruption and the process will change to kernal mode.</p>
<p><strong>kernal mode</strong><br>In Kernel mode, the executing code has complete and unrestricted access to the underlying hardware. It can execute any CPU instruction and reference any memory address. Kernel mode is generally reserved for the lowest-level, most trusted functions of the operating system. Crashes in kernel mode are catastrophic; they will halt the entire PC.</p>
<p><strong>user mode</strong><br>In User mode, the executing code has no ability to directly access hardware or reference memory. Code running in user mode must delegate to system APIs to access hardware or memory. Due to the protection afforded by this sort of isolation, crashes in user mode are always recoverable. Most of the code running on your computer will execute in user mode.</p>
<h2 id="concurrent-technologies"><a href="#concurrent-technologies" class="headerlink" title="concurrent technologies"></a>concurrent technologies</h2><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><ul>
<li>An executing instance of a program</li>
<li>text region, data region, code segment, stack region</li>
</ul>
<hr>
<ul>
<li><p><strong>Five states</strong></p>
<ul>
<li>created: by being loaded from a secondary storage device</li>
<li>waiting: it waits for the scheduler to do a so-called context switch and load the process into the processor.</li>
<li>running</li>
<li>blocked: If a process needs to wait for a resource (wait for user input or file to open, for example), it is assigned the “blocked” state.</li>
<li>terminated: Once the process finishes execution, or is terminated by the operating system, it is no longer needed.</li>
</ul>
</li>
<li><p><strong>three schedulers</strong></p>
<ul>
<li><strong>Long-Term Scheduler</strong> (job scheduler) It selects processes from pool and loads them into memory for execution</li>
<li><strong>Short-Term schduler</strong> (CPU scheduler) It selects those processes which are ready to execute</li>
<li><strong>Medium-Term Scheduler</strong> (process swapping scheduler) It can re-introduce the process into memory and execution can be continued</li>
</ul>
</li>
<li><p><strong>preemption &amp; non-preemption</strong></p>
<ul>
<li>Preemption is the act of temporarily interrupting a task being carried out by a computer system, without requiring its cooperation, and with the intention of resuming the task at a later time</li>
<li>Once resources are allocated to a process, the process holds it till it completes its burst time or switches to waiting state.</li>
</ul>
</li>
<li><p><strong>process schedule algorithms</strong></p>
<ul>
<li>FIFO or First Come, First Served (FCFS) Jobs are executed on first come, first serve basis; It is a non-preemptive scheduling algorithm; Easy to understand and implement; Poor in performance as average wait time is high.</li>
<li>Short job first: Best approach to minimize waiting time; Easy to implement in Batch systems where required CPU time is known in advance; Impossible to implement in interactive systems where required CPU time is not knownThe processer should know in advance how much time process will take.</li>
<li>Priority Based Scheduling: Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems; Each process is assigned a priority. Process with highest priority is to be executed first and so on; Processes with same priority are executed on first come first served basis; Priority can be decided based on memory requirements, time requirements or any other resource requirement.</li>
<li>Round Robin Scheduling: Round Robin is the preemptive process scheduling algorithm; Each process is provided a fix time to execute, it is called a quantum; Once a process is executed for a given time period, it is preempted and other process executes for a given time period; Context switching is used to save states of preempted processes</li>
<li>Multiple-Level Queues Scheduling: Multiple queues are maintained for processes with common characteristics; Each queue can have its own scheduling algorithms; Priorities are assigned to each queue.</li>
</ul>
</li>
</ul>
<h2 id="critical-region-amp-resource"><a href="#critical-region-amp-resource" class="headerlink" title="critical region &amp; resource"></a>critical region &amp; resource</h2><p>In concurrent programming, concurrent accesses to shared resources can lead to unexpected or erroneous behavior, so parts of the program where the shared resource is accessed are protected. This protected section is the critical section or critical region.</p>
<ul>
<li>进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li>
<li>临界区:在临界区做操作</li>
<li>退出区:清除临界区被占用的标志</li>
<li><p>剩余区：进程与临界区不相关部分的代码</p>
</li>
<li><p>soltuions：</p>
<ul>
<li>Semaphore: p v operations</li>
<li>mutex</li>
</ul>
</li>
<li>Semaphore<ul>
<li>wait: If the value of semaphore variable is not negative, decrement it by 1. If the semaphore variable is now negative, the process executing wait is blocked (i.e., added to the semaphore’s queue) until the value is greater or equal to 1. Otherwise, the process continues execution, having used a unit of the resource.</li>
<li>signal: Increments the value of semaphore variable by 1. After the increment, if the pre-increment value was negative (meaning there are processes waiting for a resource), it transfers a blocked process from the semaphore’s waiting queue to the ready queue.</li>
</ul>
</li>
</ul>
<h2 id="deadlock"><a href="#deadlock" class="headerlink" title="deadlock"></a>deadlock</h2><p>two or more competing are wating each to release resources but none of them ever.</p>
<ul>
<li><p>four conditions</p>
<ul>
<li>Mutual exclusion: The resources involved must be unshareable</li>
<li>Hold and wait: a process is currently holding at least one resource and requesting additional resources which are being held by other processes.</li>
<li>No preemption: a resource can be released only voluntarily by the process holding it.</li>
<li>Circular wait: each process must be waiting for a resource which is being held by another process, which in turn is waiting for the first process to release the resource</li>
</ul>
</li>
<li><p>solution:</p>
<ul>
<li>Ostrich algorithm.</li>
<li>allocate the resource dynamically (Bankers’ algorithm)</li>
<li>detect deadlock and recover it</li>
<li>break any conditon of above four condition</li>
</ul>
</li>
</ul>
<h2 id="Inter-process-communication"><a href="#Inter-process-communication" class="headerlink" title="Inter-process communication"></a>Inter-process communication</h2><ul>
<li>pipe, message queue</li>
<li>mutex semaphore, read write lock</li>
<li>shared memeory</li>
<li>RPC</li>
</ul>
<h2 id="memory-management"><a href="#memory-management" class="headerlink" title="memory management"></a>memory management</h2><p><img src="https://lh3.googleusercontent.com/LCsKGAxGHnyEs3EANY4n5P5ya_L5azYKGW7SIYW0x9kT6rjv4HDMJ1m28m_oLC9m-nv1d2TQhZeo9toGwMXvY8Gm5qDkan67_B7N44A1Z4Px79mbe14fVOY9wXLQDusVqZ4_u4OXCg" alt="MEMORY"></p>
<ul>
<li>virtual address: segment + segement offset</li>
<li>logical address: a logical address is the address at which an item (memory cell, storage element, network host) appears to reside from the perspective of an executing application program. segment offset</li>
<li>physical address</li>
</ul>
<p><img src="https://lh3.googleusercontent.com/fDOjO-LWHUQYO6aN5fW4FSSyM1e915oLf-bxJEg4ik7K4x6bAB9ndIbOLIF4khm82xKcYTY1FsyAe4XaQGld7bWYdqeN1ZEsC8guRAYBfi9upifgV3K_ChfsOh0Yv1JVEemRet9rLQ" alt="map"></p>
<p>首先拿到一个逻辑地址，然后拿这个逻辑地址的虚拟页号，到页表上去进行比对（没有TLB）的情况。如果比对存在，说明这个块已经被调入内存了，如果不在，则会产生缺页中断，缺页中断就会启动I/O，然后去外存调块</p>
<hr>
<p><strong>page replacement algorithms</strong></p>
<ul>
<li>FIFO</li>
<li>LRU</li>
<li>SUDO LRU</li>
<li>LFU</li>
</ul>
<p><strong>disk schedule</strong></p>
<ul>
<li>Seek Time:time taken to locate the disk arm to a specified track where the data is to be read or write</li>
<li>Rotational Latency: Rotational Latency is the time taken by the desired sector of disk to rotate into a position so that it can access the read/write heads</li>
<li>Transfer Time: Transfer time is the time to transfer the data.</li>
<li>Disk Access Time: the sum of above</li>
</ul>
<p><img src="https://lh3.googleusercontent.com/7M3qBFqSKJfvj3cH8QWSvhHu9zw1v21cm74TlXJpPCmAb4udVkSJejbN8ZyA0u-XVNz5MN6AOb-i0cOWICj9XdtRqIsR3K31TGo5ZV1ntZRx6cvPV-NcV5V8fCfdGoe9uWcDcD39vA" alt="access time"></p>
<p><strong>disk schedule algorithm</strong></p>
<ul>
<li><p>FCFS: FCFS is the simplest of all the Disk Scheduling Algorithms. In FCFS, the requests are addressed in the order they arrive in the disk queue</p>
</li>
<li><p>SSTF: In SSTF (Shortest Seek Time First), requests having shortest seek time are executed first. So, the seek time of every request is calculated in advance in queue and then they are scheduled according to their calculated seek time. As a result, the request near the disk arm will get executed first. SSTF is certainly an improvement over FCFS as it decreases the average response time and increases the throughput of system</p>
</li>
<li>SCAN: In SCAN algorithm the disk arm moves into a particular direction and services the requests coming in its path and after reaching the end of disk, it reverses its direction and again services the request arriving in its path. So, this algorithm works like an elevator and hence also known as elevator algorithm</li>
<li>CSCAN: In SCAN algorithm, the disk arm again scans the path that has been scanned, after reversing its direction. So, it may be possible that too many requests are waiting at the other end or there may be zero or few requests pending at the scanned area.</li>
<li>Look &amp; CLook</li>
</ul>
]]></content>
      
        <categories>
            
            <category> os </category>
            
        </categories>
        
        
        <tags>
            
            <tag> os </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[database]]></title>
      <url>/2017/10/09/database/</url>
      <content type="html"><![CDATA[<h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><h4 id="defination"><a href="#defination" class="headerlink" title="defination"></a>defination</h4><p>transaction is a sequence of operations and performed as a signle logic unit of work</p>
<h4 id="two-main-purposes"><a href="#two-main-purposes" class="headerlink" title="two main purposes"></a>two main purposes</h4><ul>
<li><p>To provide reliable units of work that allow correct recovery from failures and keep a database consistent even in cases of system failure</p>
</li>
<li><p>To provide isolation between programs accessing a database concurrently</p>
</li>
</ul>
<h4 id="four-properties"><a href="#four-properties" class="headerlink" title="four properties"></a>four properties</h4><ul>
<li><strong>Atomic</strong>: requires that each transaction be “all or nothing”: if one part of the transaction fails, then the entire transaction fails, and the database state is left unchanged. </li>
<li><strong>Consistent</strong>: ensures that any transaction will bring the database from one valid state to another. Integrity constraints must be maintained so that the database is consistent before and after the transaction.</li>
<li><strong>Isolated</strong>: ensures that multiple transactions can occur concurrently without leading to inconsistency of database state</li>
<li><strong>Durable</strong>: ensures that once the transaction has completed execution, the updates and modifications to the database are stored in and written to disk and they persist even is system failure occurs</li>
</ul>
<h4 id="transaction-exception"><a href="#transaction-exception" class="headerlink" title="transaction exception"></a>transaction exception</h4><ul>
<li><strong>Dirty read</strong>: occurs when a transaction is allowed to read data from a row that has been modified by another running transaction and not yet committed</li>
<li><strong>Non-repeatable reads</strong>: when during the course of a transaction, a row is retrieved twice and the values within the row differ between reads</li>
<li><strong>Phantom reads</strong>: occurs when, in the course of a transaction, two identical queries are executed, and the collection of rows returned by the second query is different from the first.</li>
<li><strong>Lost update</strong>: A second transaction writes a second value of a data-item (datum) on top of a first value written by a first concurrent transaction, and the first value is lost to other transactions running concurrently which need, by their precedence, to read the first value</li>
</ul>
<h4 id="four-isolation-level"><a href="#four-isolation-level" class="headerlink" title="four isolation level"></a>four isolation level</h4><ul>
<li><strong>Serializable</strong>:  serializability requires read and write locks (acquired on selected data) to be released at the end of the transaction. Also range-locks must be acquired when a SELECT query uses a ranged WHERE clause</li>
<li><strong>Repeatable reads</strong>:  keeps read and write locks (acquired on selected data) until the end of the transaction. However, range-locks are not managed, so phantom reads can occur.</li>
<li><strong>Read committed</strong>: keeps write locks (acquired on selected data) until the end of the transaction, but read locks are released as soon as the SELECT operation is performed.</li>
<li><strong>Read uncommitted</strong>: This is the lowest isolation level. In this level, dirty reads are allowed, so one transaction may see not-yet-committed changes made by other transactions.</li>
</ul>
<h4 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h4><ul>
<li><strong>Exclusive locks</strong>: Exclusive locks are, as the name implies, exclusively held by a single entity, usually for the purpose of writing to the record. If the locking schema was represented by a list, the holder list would contain only one entry.</li>
<li><strong>Shared locks</strong>: Shared locks differ from exclusive locks in that the holder list can contain multiple entries. Shared locks allow all holders to read the contents of the record knowing that the record cannot be changed until after the lock has been released by all holders</li>
</ul>
<hr>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><h4 id="defination-1"><a href="#defination-1" class="headerlink" title="defination"></a>defination</h4><p>A database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name</div><div class="line">    [index_type]</div><div class="line">    ON tbl_name (index_col_name,...)</div><div class="line">    [index_option]</div><div class="line">    [algorithm_option | lock_option] ...</div><div class="line"></div><div class="line">index_col_name:</div><div class="line">    col_name [(length)] [ASC | DESC]</div><div class="line"></div><div class="line">index_option:</div><div class="line">    KEY_BLOCK_SIZE [=] value</div><div class="line">  | index_type</div><div class="line">  | WITH PARSER parser_name</div><div class="line">  | COMMENT &apos;string&apos;</div><div class="line"></div><div class="line">index_type:</div><div class="line">    USING &#123;BTREE | HASH&#125;</div><div class="line"></div><div class="line">algorithm_option:</div><div class="line">    ALGORITHM [=] &#123;DEFAULT|INPLACE|COPY&#125;</div><div class="line"></div><div class="line">lock_option:</div><div class="line">    LOCK [=] &#123;DEFAULT|NONE|SHARED|EXCLUSIVE&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="indices"><a href="#indices" class="headerlink" title="indices"></a>indices</h4><ul>
<li><strong>Ordered indices</strong>: Indices are based on a sorted ordering of the values </li>
<li><strong>Hash indices</strong>: Indices are based on the values being distributed uniformly across a range of buckets. The buckets to which a value is assigned is determined by function called a hash function.</li>
</ul>
<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><ul>
<li>What are advantages of DBMS over traditional file based systems?<ul>
<li>Data redundancy and inconsistency</li>
<li>Difﬁculty in accessing data</li>
<li>Data isolation – multiple ﬁles and formats</li>
<li>Integrity problems</li>
<li>Atomicity of updates</li>
<li>Concurrent access by multiple users</li>
<li>Security problems</li>
</ul>
</li>
<li><p>What are super, primary, candidate and foreign keys?</p>
<ul>
<li>a superkey is a attribute set which can identify a row</li>
<li>a candidate key is minimal superkey</li>
<li>a primary key is one of the candidate keys</li>
<li>foreign key is a field (or collection of fields) in one table that uniquely identifies a row of another table</li>
</ul>
</li>
<li><p>What is the difference between primary key and unique constraints?</p>
<ul>
<li>Primary key cannot have NULL value, the unique constraints can have NULL values. There is only one primary key in a table, but there can be multiple unique constrains</li>
</ul>
</li>
<li><p>What is database normalization?</p>
<ul>
<li>It is a process of analyzing the given relation schemas based on their functional dependencies and primary keys to achieve the following desirable properties: Minimizing Redundancy, Minimizing the Insertion, Deletion, And Update Anomalies</li>
</ul>
</li>
<li><p>What is the difference between having and where clause?</p>
<ul>
<li>HAVING is used to specify a condition for a group or an aggregate function used in select statement. The WHERE clause selects before grouping. The HAVING clause selects rows after grouping. Unlike HAVING clause, the WHERE clause cannot contain aggregate functions</li>
<li><strong>SELECT name, section FROM tbl GROUP BY name, section HAVING COUNT(*) &gt; 1</strong></li>
</ul>
</li>
<li><p>What is Join?</p>
<ul>
<li>An SQL Join is used to combine data from two or more tables, based on a common field between them</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT StudentCourse.CourseID, Student.StudentName</div><div class="line">      FROM StudentCourse</div><div class="line">      INNER JOIN Customers </div><div class="line">      ON StudentCourse.EnrollNo = Student.EnrollNo</div><div class="line">      ORDER BY StudentCourse.CourseID;</div></pre></td></tr></table></figure>
</li>
<li><p>full join<br><img src="https://lh3.googleusercontent.com/4uK2KdyZQ4faAdOZSNHV-wQlXGRsSNY1mA2HKtGFwuSoiK4lm3GdHsA3TE-C1gxl-rbpyeJ0-IrrAUQTsJp3HL908_zTRp-TnnfQ3_OgBIVquemXkoT1v0MFZSzJMDu7kxtCB7OyBw" alt="full join"></p>
</li>
<li>left join<br><img src="https://lh3.googleusercontent.com/g5STD0f-sAMFWdPt_qz-PejAavBt5X_aJTRcY4ehkgeZL2-LGF1hCcjaTcoqHQWywoa7hveb4hQWiRNH8duj2p7kmJJSXwBE5FLDyPlyuXY1_n0uvUPtmCIuDBJ82MrBY4l_DqLsNg" alt="left join"></li>
<li>right join<br><img src="https://lh3.googleusercontent.com/ryjSfmU2QkL6eujCQwk8ypZ_VuoEWZ887PvZWaJN2w3NHyMvFTrPXX7iMi5148ygZjPwzGg6fDu2tIfzyTehXQ3ysofB_c__1D3k-pCGtcUgA8DBZ9CFk-mzub7CGOCwXhDVAT1ZLA" alt="right join"></li>
<li>inner join<br><img src="https://lh3.googleusercontent.com/3OZv-4kbUo9Z00aHDEEuvS8iuhS3BnM90qMmaa53j3G_kvMeC6kgm_4JE5qZS-kqJn40KM5bnq9_hvkEjuaS3pBlVSU49Juo6DS3bxEiussyzY3jFntof1_HNVKh2AlMr8DksikDOw" alt="inner join"></li>
</ul>
</li>
<li><p>What is a view in SQL? How to create one</p>
<ul>
<li>A view is a virtual table based on the result-set of an SQL statement. We can create using create view syntax.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  CREATE VIEW view_name AS</div><div class="line">SELECT column_name(s)</div><div class="line">FROM table_name</div><div class="line">WHERE condition</div></pre></td></tr></table></figure>
</li>
<li><p>What is a Trigger?</p>
<ul>
<li>A Trigger is a code that associated with insert, update or delete operations. The code is executed automatically whenever the associated query is executed on a table. Triggers can be useful to maintain integrity in database.</li>
</ul>
</li>
<li><p>What is a stored procedure?</p>
<ul>
<li>It contains a set of operations that are commonly used in an application to do some common database tasks.</li>
</ul>
</li>
<li><p>What is the difference between Trigger and Stored Procedure?</p>
<ul>
<li>Unlike Stored Procedures, Triggers cannot be called directly. They can only be associated with queries.</li>
</ul>
</li>
<li><p>What are clustered and non-clustered Indexes?</p>
<ul>
<li>Clustered indexes is the index according to which data is physically stored on disk. Therefore, only one clustered index can be created on a given database table.<br>Non-clustered indexes don’t define physical ordering of data, but logical ordering. Typically, a tree is created whose leaf point to disk records. B-Tree or B+ tree are used for this purpos</li>
</ul>
</li>
<li><p>Query to find 2nd highest salary of an employee?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select min(price) from (SELECT Price FROM Products order by price desc limit 2);</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> database </category>
            
        </categories>
        
        
        <tags>
            
            <tag> database </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[InterestingQuestions]]></title>
      <url>/2017/09/16/InterestingQuestions/</url>
      <content type="html"><![CDATA[<p>整理了一些很有趣的问题</p>
<ul>
<li>get maximum subarray sum no larger than k<ul>
<li>nlogn 的解法(n^2的解法我就不说了)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public int maxSumNoLargerThanK(int []nums,int k)&#123;</div><div class="line">        int sum =0,maxVal=Integer.MIN_VALUE;</div><div class="line">        TreeSet&lt;Integer&gt; set =new TreeSet&lt;&gt;();</div><div class="line">        set.add(0);</div><div class="line">        for(int x:nums)&#123;</div><div class="line">            sum +=x;</div><div class="line">            Integer it = set.ceiling(sum-k);</div><div class="line">            if(it!=null)</div><div class="line">                maxVal=Math.max(maxVal,sum-it);</div><div class="line">            set.add(sum);</div><div class="line">        &#125;</div><div class="line">        return maxVal;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>merge two sorted array to get maximum number</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//special test case: </div><div class="line">//int[]nums1= &#123;2,5,6,4,4,0&#125;;</div><div class="line">//int []nums2 = &#123;7,3,8,0,6,5,7,6,2&#125;;</div><div class="line"></div><div class="line">public boolean greater(int[]nums1,int start1,int[]nums2,int start2)&#123;</div><div class="line">        int m = nums1.length,n = nums2.length;</div><div class="line">        while(start1&lt;m &amp;&amp; start2&lt;n)&#123;</div><div class="line">            if(nums1[start1]&gt;nums2[start2])</div><div class="line">                return true;</div><div class="line">            else if(nums1[start1]&lt;nums2[start2])</div><div class="line">                return false;</div><div class="line">            else&#123;</div><div class="line">                start1++;</div><div class="line">                start2++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return start1!=m;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public int []getMaxi(int[]nums1,int[]nums2)&#123;</div><div class="line">        int m=  nums1.length,n=nums2.length;</div><div class="line">        int k = m+n;</div><div class="line">        int []res=new int[k];</div><div class="line">        int ind =0,start1=0,start2=0;</div><div class="line">        while(ind&lt;k)&#123;</div><div class="line">            res[ind++]=greater(nums1,start1,nums2,start2)?nums1[start1++]:nums2[start2++];</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.com/problems/queue-reconstruction-by-height/description/" target="_blank" rel="external">Queue Reconstruction by Height</a> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//we try to make the (h,k), k is the position we want to isert the number. How?, arrange the large number first.</div><div class="line"></div><div class="line">public int[][] reconstructQueue(int[][] people) &#123;</div><div class="line">        Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(int[] o1, int[] o2) &#123;</div><div class="line">                if(o1[0]!=o2[0])</div><div class="line">                    return Integer.compare(o2[0],o1[0]);</div><div class="line">                else</div><div class="line">                    return Integer.compare(o1[1],o2[1]);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        int n=people.length;</div><div class="line">        List&lt;int[]&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            res.add(people[i][1],people[i]);</div><div class="line">        &#125;</div><div class="line">        return res.toArray(new int[people.length][]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.com/problems/longest-repeating-character-replacement/description/" target="_blank" rel="external">Longest Repeating Character Replacement</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//424 Longest Repeating Character Replacement</div><div class="line">    //很有意思的地方在于不需要更新max，其实就是自动把&lt;len 的string过滤了</div><div class="line">    //第一次提交每次都更新了maxCnt</div><div class="line">    public int characterReplacement(String s, int k) &#123;</div><div class="line">        char []ss=s.toCharArray();</div><div class="line">        int n = ss.length,start=0,end=0,len=0,maxCnt=0;</div><div class="line">        int []cnt = new int[26];</div><div class="line">        while(end&lt;n)&#123;</div><div class="line">            maxCnt=Math.max(maxCnt,++cnt[ss[end++]-&apos;A&apos;]);</div><div class="line">            while(end-start-maxCnt&gt;k)&#123;</div><div class="line">                cnt[ss[start++]-&apos;A&apos;]--;</div><div class="line">            &#125;</div><div class="line">            len = Math.max(len,end-start);</div><div class="line">        &#125;</div><div class="line">        return len;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="https://lh3.googleusercontent.com/kxPm9yA89Ow6_VvbXnWxAhaa5w4M6r77A-w1Ls7YRvLXhSCbPqiBNykptsZ6zwDVuC1EgTCVrbNjs9WXsh45v1uui0qGZhIohNHq3JYhJpJtNo9c03ACeK5naWuMdwf_yHSxLZWXLg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OfferNegotiation]]></title>
      <url>/2017/09/15/OfferNegotiation/</url>
      <content type="html"><![CDATA[<h2 id="offer-negotiation"><a href="#offer-negotiation" class="headerlink" title="offer negotiation"></a>offer negotiation</h2><hr>
<a id="more"></a>
<p>最近听了一个关于offer negotiation的讲座，今天整理出来分享一下。<br>关于offer negotiation有多重要我就不多说了。详细可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzA4NzM3MTkzNw==&amp;mid=2652384173&amp;idx=1&amp;sn=7617ba641af29176d85df5530087af50&amp;chksm=8bd6f263bca17b75f944b50e31381fa48447b913cd092e15b854bb086b67751746d6667b361a&amp;mpshare=1&amp;scene=1&amp;srcid=0916KfxnZrDLFvwVjNR19Ywl&amp;key=bc73b2383c76f4311b1819c9d3cba3a2afcb60972da9e3c727fc6d05e5845c0e462bf038139f17b5a6fb9f9033d8216da008e3a032a4da055bb1eb7d0f9f0959483329994fa4320db8f1ead627df8f0c" target="_blank" rel="external">Warald_一亩三分地</a></p>
<ul>
<li>过程很微妙，需要有耐心</li>
<li>有一定风险，结果不能确定</li>
<li>没有唯一正确的方法，需要分析当时的情况</li>
<li>并不能满足所有需求，需要有符合实际的exception</li>
<li>不是战争，没有输赢，win-win 是重点</li>
</ul>
<p>在整个过程中，态度一定要<strong>坚定大方</strong></p>
<p><strong>公司喜欢经常跳槽的人还是固定不动的人？</strong></p>
<ol>
<li>经常跳槽的人<ul>
<li>能挖动</li>
<li>市场需求量大</li>
<li>技能与时俱进</li>
<li>知道面试行情，经验足，容易过面试</li>
</ul>
</li>
<li>固守不动的人<ul>
<li>忠诚度高</li>
<li>技术老旧，在现有公司止步不前</li>
<li>无法与时俱进</li>
<li>经验不足，通过面试的概率低</li>
</ul>
</li>
</ol>
<p><strong>如何看待hr说按能力给出相应的package？</strong></p>
<ul>
<li>模糊词汇</li>
<li>能力高低难以量化</li>
<li>对方的战术体现</li>
</ul>
<p><strong>应届生的工资都是统一的？</strong></p>
<ul>
<li>与面试表现成正比</li>
<li>平均值作为参考</li>
<li>offer negotiation 后结果不同</li>
<li>lowball vs rockstar</li>
</ul>
<p><strong>有哪些东西可以去negotiate？</strong></p>
<ul>
<li>relocation expense</li>
<li>vocation / sick time</li>
<li>telecommute (work from home)</li>
<li>base salary</li>
<li>stock options</li>
<li>sign bonus</li>
</ul>
<p><strong>negotiate 之前需要做哪些准备？</strong></p>
<ul>
<li>目前市场上同level的平均工资</li>
<li>该公司目前找人和negotiation的基本趋势</li>
<li>该公司同等level员工的平均工资</li>
<li>range: lowball + 15% — rockstar - 10%</li>
</ul>
<p><strong>negotiate的时候是一次性说完还是多次说？</strong></p>
<p>一次性说完，而且把最想提高的那部分说完。hr和你谈话的时间不会太久，而且hr基本会盯着一点说很久，这样你就没有太多机会说其他的选项了。此外，站在hr的角度上看，她是不希望你多次找她谈条件。</p>
<p><strong>如何提高你的negotion power?</strong></p>
<ul>
<li>同一时期拥有更多的offer<ul>
<li>紧密的安排面试</li>
<li>同一时期投多份简历</li>
</ul>
</li>
<li>current job做为谈判筹码<ul>
<li>提升title</li>
</ul>
</li>
</ul>
<p><strong>具体数字问题</strong></p>
<ul>
<li>让对方先说</li>
<li>申请的时候对方让填具体数字，填 0</li>
<li>技巧<ul>
<li>反问对方具体range，继续问出一系列问题</li>
<li>可以说 depends on overall<br>compensation including benefits</li>
<li>给出一个larger 的range</li>
</ul>
</li>
</ul>
<p><strong>不应该出现的negotiation 点</strong></p>
<ul>
<li>家庭问题</li>
<li>经济困难</li>
<li>身体因素</li>
</ul>
<p>这些会给人一种不积极，不专业，消极的印象</p>
<p><strong>和Hire Manager, HR 聊什么？</strong></p>
<ol>
<li>和HM打外交战<ul>
<li>聊技术，聊发展，聊vision</li>
<li>原则就是让HM 对你产生非常好的印象</li>
<li>HM的意见会最终影响你的package</li>
</ul>
</li>
<li>和HR打拉锯战<ul>
<li>第一阶段： 互相测试，迂转千回，就是不告诉她具体数字。就说签了nda</li>
<li>第二阶段： 双方激战，借力打力，互不相让。反问对方的工资range</li>
<li>第三阶段： 反转优势， 从容不迫，无中生有。停顿3秒原则，给出预期的数字就接。</li>
</ul>
</li>
</ol>
<p><strong>关键部分都要留下书面信息</strong></p>
<ol>
<li>offer 细节</li>
<li>具体的工作任务和责任</li>
<li>之后拿到更多薪水的步骤</li>
</ol>
<p><strong>你要知道的信息</strong></p>
<ol>
<li>找一个engineer 平均花费20000$</li>
<li>offer 数字留有空间</li>
<li>hr会猜测你目前的薪资水平</li>
</ol>
]]></content>
      
        <categories>
            
            <category> work </category>
            
        </categories>
        
        
        <tags>
            
            <tag> offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac_ruby_setup]]></title>
      <url>/2017/09/07/mac-ruby-setup/</url>
      <content type="html"><![CDATA[<h3 id="mac-install-ruby"><a href="#mac-install-ruby" class="headerlink" title="mac install ruby"></a>mac install ruby</h3><hr>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">brew install rbenv ruby-build</div><div class="line"></div><div class="line"># Add rbenv to bash so that it loads every time you open a terminal</div><div class="line">echo &apos;if which rbenv &gt; /dev/null; then eval &quot;$(rbenv init -)&quot;; fi&apos; &gt;&gt; ~/.bash_profile</div><div class="line">source ~/.bash_profile</div><div class="line"></div><div class="line"># Install Ruby</div><div class="line">rbenv install 2.4.1</div><div class="line">rbenv global 2.4.1</div><div class="line">ruby -v</div><div class="line"></div><div class="line"># you should install the Command Line tools as they aren&apos;t installed by default (xcode)</div><div class="line"></div><div class="line">xcode-select --install</div><div class="line"></div><div class="line">gem install rails -v 5.1.3</div><div class="line"></div><div class="line">rbenv rehash</div><div class="line"></div><div class="line">rails -v</div><div class="line"></div><div class="line"></div><div class="line"># create new application</div><div class="line">rails new blog</div><div class="line"></div><div class="line"># if webpacker is not installed</div><div class="line">brew install yarn</div><div class="line">rails webpacker:install</div><div class="line"></div><div class="line"># run server</div><div class="line">rails server</div></pre></td></tr></table></figure>
<hr>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># start default web server: puma</div><div class="line">rails server</div></pre></td></tr></table></figure>
<h3 id="drop-table"><a href="#drop-table" class="headerlink" title="drop table"></a>drop table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rails console</div><div class="line">ActiveRecord::Migration.drop_table(:users)</div><div class="line"></div><div class="line"># where users is the table name. And done, worked for me!</div></pre></td></tr></table></figure>
<h3 id="destroy-model"><a href="#destroy-model" class="headerlink" title="destroy model"></a>destroy model</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rails destroy model student</div><div class="line"></div><div class="line"># where student is the model</div></pre></td></tr></table></figure>
<h3 id="generate-model"><a href="#generate-model" class="headerlink" title="generate model"></a>generate model</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">rails generate model student \</div><div class="line">uin:integer first_name:string middle_name:string last_name:string \</div><div class="line">level: integer \</div><div class="line">email:string \</div><div class="line">phone: string \</div><div class="line">assigned: boolean \</div><div class="line">advisor_email: string \</div><div class="line">can_ta: boolean \</div><div class="line">can_grader: boolean \</div><div class="line">can_sgrader: boolean \</div><div class="line">perferences: string \</div><div class="line">date_enrolled: date \</div><div class="line">last_modified: timestamp</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> ruby </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[csce606_github]]></title>
      <url>/2017/09/06/csce606-github/</url>
      <content type="html"><![CDATA[<p>在已经建好organization 和 team的情况下，可以按照如下步骤进行协同开发</p>
<hr>
<a id="more"></a>
<h4 id="第一次提交"><a href="#第一次提交" class="headerlink" title="第一次提交"></a>第一次提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">git clone https://github.tamu.edu/HelloWorld/TA_Assignment_System.git</div><div class="line"></div><div class="line">// change to dev branch</div><div class="line">git checkout dev</div><div class="line"></div><div class="line">//check what&apos;s current branch</div><div class="line">git branch</div><div class="line"></div><div class="line">//after add or modified some files</div><div class="line">git add file1.txt file2.txt file3.txt</div><div class="line"></div><div class="line">//check file status </div><div class="line">git status</div><div class="line"></div><div class="line">//pull the latest dev version from remote</div><div class="line">//you should always pull before push</div><div class="line">git pull origin dev</div><div class="line"></div><div class="line">//commit files and add explanation</div><div class="line">git commit -m &quot;your explanation&quot;</div><div class="line"></div><div class="line">//push to remote</div><div class="line">git push origin dev</div></pre></td></tr></table></figure>
<h4 id="以后的提交"><a href="#以后的提交" class="headerlink" title="以后的提交"></a>以后的提交</h4><p>只需要上面步骤的后面几步了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git add file1.txt file2.txt file3.txt</div><div class="line"></div><div class="line">git pull origin dev</div><div class="line"></div><div class="line">git commit -m &quot;your explanation&quot;</div><div class="line"></div><div class="line">git push origin dev</div></pre></td></tr></table></figure>
<h2 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h2><hr>
<ul>
<li>add/delete files</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//add specific files </div><div class="line">git add [file1] [file2] ...</div><div class="line"></div><div class="line">//add current dir including its subdirs</div><div class="line">git add [dir]</div><div class="line"></div><div class="line">//add all files in current dir</div><div class="line">git add .</div><div class="line"></div><div class="line">//delete specific files</div><div class="line">//delete files in your disk and index area</div><div class="line">git rm -f [file1] [file2] ...</div><div class="line"></div><div class="line">//delete files in index area but they remains in your disk</div><div class="line">git rm --cached [file1] [file2] ...</div></pre></td></tr></table></figure>
<ul>
<li>branch</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//list all local branches</div><div class="line">git branch</div><div class="line"></div><div class="line">//list all remote branches</div><div class="line">git branch -r</div><div class="line"></div><div class="line">//list all local &amp; remote branches</div><div class="line">git branch -a</div><div class="line"></div><div class="line">//create a new branch, but remain in the original branch</div><div class="line">git branch [branch-name]</div><div class="line"></div><div class="line">//create a new branch and change to new branch</div><div class="line">git checkout -b [branch]</div><div class="line"></div><div class="line">//change to specific branch</div><div class="line">git checkout [branch-name]</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MultiThread]]></title>
      <url>/2017/08/12/MultiThread/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h2 id="selling-tickets"><a href="#selling-tickets" class="headerlink" title="selling tickets"></a>selling tickets</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">public class SellThread implements Runnable</div><div class="line">&#123;</div><div class="line">    private int ticketCount = 10;// total tickets, all thread will visit</div><div class="line">    Object mutex = new Object();// mutex</div><div class="line">    /**</div><div class="line">     * selling ticket</div><div class="line">     */</div><div class="line">    public  void sellTicket()</div><div class="line">    &#123;</div><div class="line">        synchronized (mutex) </div><div class="line">        &#123;</div><div class="line">            if (ticketCount &gt; 0)</div><div class="line">            &#123;</div><div class="line">                ticketCount--;</div><div class="line">                System.out.println(Thread.currentThread().getName()</div><div class="line">                        + &quot;selling...&quot; + ticketCount + &quot;tickets left&quot;);</div><div class="line">            &#125;</div><div class="line">            else</div><div class="line">            &#123;</div><div class="line">                System.out.println(&quot;sell done！&quot;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void run()</div><div class="line">    &#123;</div><div class="line">        while (ticketCount &gt; 0)</div><div class="line">        &#123;</div><div class="line">            sellTicket();</div><div class="line">            </div><div class="line">            //sleep 1 millisecond so that each thread</div><div class="line">            //has the chance to sell ticket</div><div class="line">            try</div><div class="line">            &#123;</div><div class="line">                Thread.sleep(1);</div><div class="line">            &#125;</div><div class="line">            catch (InterruptedException e)</div><div class="line">            &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class Test&#123;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        SellThread runTicekt = new SellThread();//one instance will lead to only one object </div><div class="line">        //,so we have only one mutex        </div><div class="line">        Thread th1 = new Thread(runTicekt, &quot;window1&quot;);</div><div class="line">        Thread th2 = new Thread(runTicekt, &quot;window2&quot;);</div><div class="line">        Thread th3 = new Thread(runTicekt, &quot;window3&quot;);</div><div class="line">        Thread th4 = new Thread(runTicekt, &quot;window4&quot;);</div><div class="line">        th1.start();</div><div class="line">        th2.start();</div><div class="line">        th3.start();</div><div class="line">        th4.start();</div><div class="line">        try&#123;</div><div class="line">            th4.join();</div><div class="line">            th3.join();</div><div class="line">            th2.join();</div><div class="line">            th1.join();</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> os </category>
            
        </categories>
        
        
        <tags>
            
            <tag> thread </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DFSQuestions]]></title>
      <url>/2017/08/01/DFSQuestions/</url>
      <content type="html"><![CDATA[<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><hr>
<a id="more"></a>
<ul>
<li>200 Number of islands</li>
<li>110 Balanced binary tree</li>
<li>124 Binary Tree Maximum Path Sum</li>
<li>99 Recover Binary Search Tree</li>
<li>133 Clone Graph</li>
<li>114 Flatten Binary Tree to Linked List</li>
<li>199 Binary Tree Right Side View</li>
<li>301 Remove Invalid Parentheses</li>
<li>337 House Robber III</li>
<li>339 Nested List Weight Sum</li>
</ul>
<h3 id="200-Number-of-islands"><a href="#200-Number-of-islands" class="headerlink" title="200 Number of islands"></a>200 Number of islands</h3><p>思路： 求多少个联通块，dfs，bfs，unionfind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void dfs(int x,int y,boolean[][]vis,char[][]grid)&#123;</div><div class="line">        if(x&lt;0||y&lt;0||x&gt;=grid.length||y&gt;=grid[0].length||vis[x][y]||grid[x][y]==&apos;0&apos;)</div><div class="line">            return;</div><div class="line">        vis[x][y]=true;</div><div class="line">        dfs(x+1,y,vis,grid);</div><div class="line">        dfs(x-1,y,vis,grid);</div><div class="line">        dfs(x,y+1,vis,grid);</div><div class="line">        dfs(x,y-1,vis,grid);</div><div class="line">    &#125;</div><div class="line">    public int numIslands(char[][] grid) &#123;</div><div class="line">        if(grid.length==0||grid[0].length==0)</div><div class="line">            return 0;</div><div class="line">        int m = grid.length,n=grid[0].length;</div><div class="line">        int cnt=0;</div><div class="line">        boolean [][]vis=new boolean[m][n];</div><div class="line">        for(int i=0;i&lt;m;++i)&#123;</div><div class="line">            for(int j=0;j&lt;n;++j)&#123;</div><div class="line">                if(grid[i][j]==&apos;1&apos; &amp;&amp; !vis[i][j])&#123;</div><div class="line">                    cnt++;</div><div class="line">                    dfs(i,j,vis,grid);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return cnt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="110-Balanced-binary-tree"><a href="#110-Balanced-binary-tree" class="headerlink" title="110 Balanced binary tree"></a>110 Balanced binary tree</h3><p>思路： 树平衡这种题一定要计算高度的。笨点的每个结点都要查左右子树高度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int getHeight(TreeNode root)&#123;</div><div class="line">        if(root==null)</div><div class="line">            return 0;</div><div class="line">        int l = getHeight(root.left);</div><div class="line">        int r = getHeight(root.right);</div><div class="line">        if(l==-1||r==-1||Math.abs(l-r)&gt;1)</div><div class="line">            return -1;</div><div class="line">        return Math.max(l,r)+1;</div><div class="line">    &#125;</div><div class="line">    public boolean isBalanced(TreeNode root) &#123;</div><div class="line">        return getHeight(root)!=-1;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124 Binary Tree Maximum Path Sum"></a>124 Binary Tree Maximum Path Sum</h3><p>思路： 第一次做的时候一脸懵逼，其实仔细想想，我们需要借助一个dfs函数返回一个值供父节点使用，这个值因该是math.max(cur.val,cur.val+left,cur.val+right),不能有cur.val+left+right,这样就会cross，不能再向上拓展了。全局变量记录这四项的最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public int dfs(TreeNode root,int []res)&#123;</div><div class="line">       if(root==null)</div><div class="line">           return 0;</div><div class="line">       int l=dfs(root.left,res);</div><div class="line">       int r = dfs(root.right,res);</div><div class="line">       int ans=Math.max(l+root.val,Math.max(r+root.val,root.val));</div><div class="line">       res[0]=Math.max(Math.max(ans,res[0]),l+r+root.val);</div><div class="line">       return ans;</div><div class="line">   &#125;</div><div class="line">   public int maxPathSum(TreeNode root) &#123;</div><div class="line">       int []res=new int[1];</div><div class="line">       res[0]=Integer.MIN_VALUE;</div><div class="line">       dfs(root,res);</div><div class="line">       return res[0];</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99 Recover Binary Search Tree"></a>99 Recover Binary Search Tree</h3><p>思路： 中序遍历，然后会发现两次pre.val&gt;root.val,你画画图试试，第一次的异常点事pre，第二个异常点事root。笨一点就可以先把值打印，然后就排序，赋值回去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public TreeNode first=null;</div><div class="line">    public TreeNode second=null;</div><div class="line">    public TreeNode pre=null;</div><div class="line"></div><div class="line">    public void inorder(TreeNode root)&#123;</div><div class="line">        if(root==null)</div><div class="line">            return;</div><div class="line">        inorder(root.left);</div><div class="line">        if(pre!=null)&#123;</div><div class="line">            if(pre.val&gt;root.val)&#123;</div><div class="line">                if(first==null)</div><div class="line">                    first=pre;</div><div class="line">                second=root;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        pre=root;</div><div class="line">        inorder(root.right);</div><div class="line">        //pre=root;</div><div class="line">    &#125;</div><div class="line">    public void recoverTree(TreeNode root)&#123;</div><div class="line">        inorder(root);</div><div class="line">        if(first!=null &amp;&amp; second!=null)&#123;</div><div class="line">            int tmp = first.val;</div><div class="line">            first.val=second.val;</div><div class="line">            second.val=tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="133-Clone-Graph"><a href="#133-Clone-Graph" class="headerlink" title="133 Clone Graph"></a>133 Clone Graph</h3><p>思路： recursive 的方法太简单，简单说说bfs的way，遍历图，如果map里没有，就创建新的node，否则不创建，但是最后都要关联起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123;</div><div class="line">        Map&lt;UndirectedGraphNode,UndirectedGraphNode&gt;map=new HashMap&lt;&gt;();</div><div class="line">        if(node==null)</div><div class="line">            return null;</div><div class="line">        Queue&lt;UndirectedGraphNode&gt;q=new LinkedList&lt;&gt;();</div><div class="line">        q.offer(node);</div><div class="line">        map.put(node,new UndirectedGraphNode(node.label));</div><div class="line">        while(!q.isEmpty())&#123;</div><div class="line">            UndirectedGraphNode top = q.poll();</div><div class="line">            for(UndirectedGraphNode ne:top.neighbors)&#123;</div><div class="line">                if(!map.containsKey(ne))&#123;</div><div class="line">                    map.put(ne,new UndirectedGraphNode(ne.label));</div><div class="line">                    q.offer(ne);</div><div class="line">                &#125;</div><div class="line">                map.get(top).neighbors.add(map.get(ne));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return map.get(node);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    //recursive way</div><div class="line">    </div><div class="line">    Map&lt;UndirectedGraphNode,UndirectedGraphNode&gt;map=new HashMap&lt;&gt;();</div><div class="line">    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123;</div><div class="line">        if(node==null)</div><div class="line">            return null;</div><div class="line">        if(!map.containsKey(node))&#123;</div><div class="line">            map.put(node,new UndirectedGraphNode(node.label));</div><div class="line">            for(UndirectedGraphNode child:node.neighbors)</div><div class="line">                map.get(node).neighbors.add(cloneGraph(child));</div><div class="line">        &#125;</div><div class="line">        return map.get(node);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114 Flatten Binary Tree to Linked List"></a>114 Flatten Binary Tree to Linked List</h3><p>思路：后续遍历，仔细揣摩一下，当然，也可以iterative</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">TreeNode pre=null;</div><div class="line">    public void flatten(TreeNode root) &#123;</div><div class="line">        if(root==null)</div><div class="line">            return;</div><div class="line">        flatten(root.right);</div><div class="line">        flatten(root.left);</div><div class="line">        root.right=pre;</div><div class="line">        root.left=null;</div><div class="line">        pre=root;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public void flatten(TreeNode root) &#123;</div><div class="line">        if(root==null)</div><div class="line">            return;</div><div class="line">        TreeNode node = root;</div><div class="line">        while(node!=null)&#123;</div><div class="line">            if(node.left!=null)&#123;</div><div class="line">                TreeNode cur = node.left;</div><div class="line">                while(cur.right!=null)</div><div class="line">                    cur=cur.right;</div><div class="line">                cur.right=node.right;</div><div class="line">                node.right=node.left;</div><div class="line">                node.left=null;</div><div class="line">            &#125;</div><div class="line">            node=node.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199 Binary Tree Right Side View"></a>199 Binary Tree Right Side View</h3><p>思路： 和level order很像, bfs的方法我就懒得写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void dfs(List&lt;Integer&gt;res,TreeNode root,int level)&#123;</div><div class="line">       if(root==null)</div><div class="line">           return;</div><div class="line">       if(level&gt;=res.size())</div><div class="line">           res.add(root.val);</div><div class="line">       dfs(res,root.right,level+1);</div><div class="line">       dfs(res,root.left,level+1);</div><div class="line">   &#125;</div><div class="line">   public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</div><div class="line">       List&lt;Integer&gt;res=new ArrayList&lt;&gt;();</div><div class="line">       dfs(res,root,0);</div><div class="line">       return res;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="301-Remove-Invalid-Parentheses"><a href="#301-Remove-Invalid-Parentheses" class="headerlink" title="301 Remove Invalid Parentheses"></a>301 Remove Invalid Parentheses</h3><p>思路： bfs，暴力枚举每个删除的位置。dfs也可，但是还没掌握，太精妙了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public boolean isValid(String s)&#123;</div><div class="line">        char []ss=s.toCharArray();</div><div class="line">        int cnt=0;</div><div class="line">        for(char c:ss)&#123;</div><div class="line">            if(c==&apos;(&apos;)</div><div class="line">                cnt++;</div><div class="line">            else if(c==&apos;)&apos;)</div><div class="line">                cnt--;</div><div class="line">            if(cnt&lt;0)</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return cnt==0;</div><div class="line">    &#125;</div><div class="line">    public List&lt;String&gt; removeInvalidParentheses(String s) &#123;</div><div class="line">        List&lt;String&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        if(isValid(s))&#123;</div><div class="line">            res.add(s);</div><div class="line">            return res;</div><div class="line">        &#125;</div><div class="line">        Queue&lt;String&gt;q=new LinkedList&lt;&gt;();</div><div class="line">        q.offer(s);</div><div class="line">        Map&lt;String,Boolean&gt;vis=new HashMap&lt;&gt;();</div><div class="line">        boolean next=true;</div><div class="line">        vis.put(s,true);</div><div class="line">        while(next &amp;&amp; !q.isEmpty())&#123;</div><div class="line">            int size=q.size();</div><div class="line">            while(size -- &gt;0)&#123;</div><div class="line">                String top = q.poll();</div><div class="line">                int len =top.length();</div><div class="line">                for(int i=0;i&lt;len;++i)&#123;</div><div class="line">                    if(s.charAt(i)==&apos;(&apos;||s.charAt(i)==&apos;)&apos;)&#123;</div><div class="line">                        String sub = top.substring(0,i)+top.substring(i+1);</div><div class="line">                        if(!vis.containsKey(sub))&#123;</div><div class="line">                            vis.put(sub,true);</div><div class="line">                            q.offer(sub);</div><div class="line">                            if(isValid(sub))&#123;</div><div class="line">                                next=false;</div><div class="line">                                res.add(sub);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337 House Robber III"></a>337 House Robber III</h3><p>思路： dfs 返回一个长度为2的数组，一个代表rob了当前node，一个代表没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int[]dfsRob(TreeNode root)&#123;</div><div class="line">        if(root==null)</div><div class="line">            return new int[]&#123;0,0&#125;;</div><div class="line">        int []res=new int[2];</div><div class="line">        //res[0] rob root; res[1] not rob root;</div><div class="line">        int []l = dfsRob(root.left);</div><div class="line">        int []r =dfsRob(root.right);</div><div class="line">        res[0]=l[1]+r[1]+root.val;</div><div class="line">        //好好想想，没选中当前node，不代表最大值一定是选左子节点，右子节点。</div><div class="line">        res[1]=Math.max(l[0],l[1])+Math.max(r[0],r[1]);</div><div class="line">        return res;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public int rob(TreeNode root) &#123;</div><div class="line">        int []res=dfsRob(root);</div><div class="line">        return Math.max(res[0],res[1]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="339-Nested-List-Weight-Sum"><a href="#339-Nested-List-Weight-Sum" class="headerlink" title="339 Nested List Weight Sum"></a>339 Nested List Weight Sum</h3><p>思路：普通的level by level 求和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void dfs(List&lt;NestedInteger&gt;nestedList,int[]res,int level)&#123;</div><div class="line">        int n=nestedList.size();</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            if(nestedList.get(i).isInteger())&#123;</div><div class="line">                res[0]+=level*nestedList.get(i).getInteger();</div><div class="line">            &#125;else&#123;</div><div class="line">                dfs(nestedList.get(i).getList(),res,level+1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123;</div><div class="line">        int []res=new int[1];</div><div class="line">        dfs(nestedList,res,1);</div><div class="line">        return res[0];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BFSQuestions]]></title>
      <url>/2017/07/23/BFSQuestions/</url>
      <content type="html"><![CDATA[<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><hr>
<a id="more"></a>
<ul>
<li>199 Binary Tree Right Side View</li>
</ul>
<p>s<br>思路： dfs 和  bfs，其实和level order的两种差不多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public void dfs(TreeNode node,List&lt;Integer&gt;res,int level)&#123;</div><div class="line">        if(node==null)</div><div class="line">            return;</div><div class="line">        if(level&gt;=res.size())</div><div class="line">            res.add(node.val);</div><div class="line">        dfs(node.right,res,level+1);</div><div class="line">        dfs(node.left,res,level+1);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        dfs(root,res,0);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    public List&lt;Integer&gt;rightSideViewByBFS(TreeNode root)&#123;</div><div class="line">        List&lt;Integer&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        if(root==null)</div><div class="line">            return res;</div><div class="line">        Queue&lt;TreeNode&gt;q=new LinkedList&lt;&gt;();</div><div class="line">        while(!q.isEmpty())&#123;</div><div class="line">            int size= q.size();</div><div class="line">            while(size --&gt;0)&#123;</div><div class="line">                TreeNode top=q.poll();</div><div class="line">                if(size==0)</div><div class="line">                    res.add(top.val);</div><div class="line">                if(top.left!=null)</div><div class="line">                    q.offer(top.left);</div><div class="line">                if(top.right!=null)</div><div class="line">                    q.offer(top.right);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="Expectations"><a href="#Expectations" class="headerlink" title="Expectations"></a>Expectations</h1><hr>
<ul>
<li>改天把internship所涉及到的tech总结一下。</li>
<li>要对internship的project表现出激情</li>
</ul>
<p><img src="https://lh3.googleusercontent.com/RlEdIBHmvtJYrCdt4QOs3u21KcLmUZBoNYpvbY-CRkN6W2giTU9nMR68LX6EOYNCYfJb97nxn_vNTNi-zfPnxIxoexH6QyeW9jDdDvM6qOu_BSvUEdGgIjvFei3LSR_tbW33jDH0iQ" alt="Sandford Univ"></p>
<hr>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BacktrackingQuestions]]></title>
      <url>/2017/07/23/BacktrackingQuestions/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<ul>
<li>10 Regular Expression Matching</li>
<li>17 Letter Combinations of a Phone Number</li>
<li>22     Generate Parentheses</li>
<li>46     Permutations</li>
<li>89 Gray Code</li>
<li>79     Word Search</li>
<li>140 Word Break II</li>
<li>78     N-Queens</li>
<li>37 Sudoku Solver</li>
<li>52 N-Queens II</li>
<li>93 Restore IP Addresses</li>
<li>131 Palindrome Partitioning</li>
<li>44 Wildcard Matching</li>
<li>60 Permutation Sequence</li>
<li>212 Word Search II</li>
<li>216 Combination Sum III</li>
<li>47 Permutations II</li>
<li>357 Count Numbers with Unique Digits</li>
<li>90 Subsets II</li>
<li>291 Word Pattern II</li>
<li>320 Generalized Abbreviation </li>
<li>401 Binary Watch</li>
<li>40 Combination Sum II</li>
<li>211 Add and Search Word - Data structure design</li>
<li>254 Factor Combinations </li>
<li>267 Palindrome Permutation II </li>
<li>351 Android Unlock Patterns </li>
<li>294 filp games II</li>
<li>526 Beautiful Arrangement</li>
</ul>
<hr>
<h3 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17 Letter Combinations of a Phone Number"></a>17 Letter Combinations of a Phone Number</h3><p>思路：先建立数字到字符的映射，然后回溯解决,  可以用map也可以用String 数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public void dfs(List&lt;String&gt;res,String digits,String[]num,int ind,String path)&#123;</div><div class="line">        if(ind==digits.length())&#123;</div><div class="line">            res.add(path);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if(ind&gt;digits.length())</div><div class="line">            return;</div><div class="line">        for(int i=0;i&lt;num[digits.charAt(ind)-&apos;2&apos;].length();++i)&#123;</div><div class="line">            dfs(res,digits,num,ind+1,path+num[digits.charAt(ind)-&apos;2&apos;].charAt(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</div><div class="line">        String []num = &#123;&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;</div><div class="line">        List&lt;String&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        if(digits.isEmpty())</div><div class="line">            return res;</div><div class="line">        dfs(res,digits,num,0,&quot;&quot;);</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22 Generate Parentheses"></a>22 Generate Parentheses</h3><p>思路： 可以用回溯法或者模拟出栈的过程，可以了解下卡塔兰数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public List&lt;String&gt; generateParenthesis(int n) &#123;</div><div class="line">        List&lt;String&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        generateParenthesis(n,0,0,res,&quot;&quot;);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void generateParenthesis(int n,int left,int right,List&lt;String&gt;res,String path)&#123;</div><div class="line">        if(left==n &amp;&amp; right==n)&#123;</div><div class="line">            res.add(path);</div><div class="line">            return ;</div><div class="line">        &#125;</div><div class="line">        if(left&lt;n)</div><div class="line">            generateParenthesis(n,left+1,right,res,path+&quot;(&quot;);</div><div class="line">        if(right&lt;left)</div><div class="line">            generateParenthesis(n,left,right+1,res,path+&quot;)&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public void dfs(List&lt;String&gt;res,String path,Stack&lt;Integer&gt;input,Stack&lt;Integer&gt;stk,int n)&#123;</div><div class="line">        if(path.length()==2*n)&#123;</div><div class="line">            res.add(path);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if(!input.isEmpty())&#123;</div><div class="line">            int top = input.pop();</div><div class="line">            stk.push(top);</div><div class="line">            dfs(res,path+&quot;(&quot;,input,stk,n);</div><div class="line">            stk.pop();</div><div class="line">            input.push(top);</div><div class="line">        &#125;</div><div class="line">        if(!stk.isEmpty())&#123;</div><div class="line">            int top = stk.pop();</div><div class="line">            dfs(res,path+&quot;)&quot;,input,stk,n);</div><div class="line">            stk.push(top);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;String&gt;generateParenthesis(int n)&#123;</div><div class="line">        Stack&lt;Integer&gt; input=new Stack&lt;&gt;();</div><div class="line">        Stack&lt;Integer&gt; stk=new Stack&lt;&gt;();</div><div class="line">        for(int i=n;i&gt;=1;i--)</div><div class="line">            input.push(i);</div><div class="line">        List&lt;String&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        dfs(res,&quot;&quot;,input,stk,n);</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46 Permutations"></a>46 Permutations</h3><p>思路： 每次都从第一个元素开始，然后判断是不是已经装进path里了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void dfs(int[]nums,List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;path)&#123;</div><div class="line">        if(path.size()==nums.length)&#123;</div><div class="line">            res.add(new ArrayList&lt;&gt;(path));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</div><div class="line">            boolean valid=true;</div><div class="line">            for(int x:path)&#123;</div><div class="line">                if(x==nums[i])&#123;</div><div class="line">                    valid=false;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if(valid)&#123;</div><div class="line">                path.add(nums[i]);</div><div class="line">                dfs(nums,res,path);</div><div class="line">                path.remove(path.size()-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt;path=new ArrayList&lt;&gt;();</div><div class="line">        dfs(nums,res,path);</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89 Gray Code"></a>89 Gray Code</h3><p>思路： 有计算公式，也可以观察规律，每次都是从以后的数组的后面开始|一个(1&lt;&lt;i)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public List&lt;Integer&gt; grayCode(int n) &#123;</div><div class="line">        List&lt;Integer&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        res.add(0);</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            int size=res.size();</div><div class="line">            for(int j=size-1;j&gt;=0;--j)&#123;</div><div class="line">                res.add(res.get(j)|(1&lt;&lt;i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79 Word Search"></a>79 Word Search</h3><p>思路： 就是四个方向分别去找，注意不能访问已经访问过的点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public boolean exist(char[][]board,int x,int y,String word,int ind,boolean[][]vis,int[]dx,int[]dy)&#123;</div><div class="line">        if(word.length()==ind)</div><div class="line">            return true;</div><div class="line">        if(x&gt;=board.length||x&lt;0||y&gt;=board[0].length||y&lt;0||vis[x][y]||word.charAt(ind)!=board[x][y])</div><div class="line">            return false;</div><div class="line">        vis[x][y]=true;</div><div class="line">        for(int k=0;k&lt;4;++k)&#123;</div><div class="line">            int nx =x+dx[k];</div><div class="line">            int ny =y+dy[k];</div><div class="line">            if(exist(board,nx,ny,word,ind+1,vis,dx,dy))</div><div class="line">                return true;</div><div class="line">        &#125;</div><div class="line">        vis[x][y]=false;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    public boolean exist(char[][] board, String word) &#123;</div><div class="line">        if(board.length==0||board[0].length==0)</div><div class="line">            return false;</div><div class="line">        int m = board.length,n=board[0].length;</div><div class="line">        boolean [][]vis = new boolean[m][n];</div><div class="line">        int []dx=&#123;1,-1,0,0&#125;;</div><div class="line">        int []dy =&#123;0,0,1,-1&#125;;</div><div class="line">        for(int i=0;i&lt;m;++i)&#123;</div><div class="line">            for(int j=0;j&lt;n;++j)&#123;</div><div class="line">                if(exist(board,i,j,word,0,vis,dx,dy))</div><div class="line">                    return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="212-Word-Search-II"><a href="#212-Word-Search-II" class="headerlink" title="212 Word Search II"></a>212 Word Search II</h3><p>思路： 把这些words装进trie里，然后利用trie进行查找,主要注意的是dfs里的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">class TrieNode &#123;</div><div class="line">    public boolean isEnd;</div><div class="line">    public TrieNode []children=null;</div><div class="line">    public TrieNode()&#123;</div><div class="line">        children=new TrieNode[26];</div><div class="line">        isEnd=false;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line">class Trie &#123;</div><div class="line">    /** Initialize your data structure here. */</div><div class="line">    private TrieNode root;</div><div class="line">    public Trie() &#123;</div><div class="line">        root=new TrieNode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public TrieNode getRoot()&#123;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line">    /** Inserts a word into the trie. */</div><div class="line">    public void insert(String word) &#123;</div><div class="line">        char []ss=word.toCharArray();</div><div class="line">        TrieNode cur=root;</div><div class="line">        for(char c:ss)&#123;</div><div class="line">            TrieNode node=cur.children[c-&apos;a&apos;];</div><div class="line">            if(node==null)&#123;</div><div class="line">                cur.children[c-&apos;a&apos;]=new TrieNode();</div><div class="line">            &#125;</div><div class="line">            cur=cur.children[c-&apos;a&apos;];</div><div class="line">        &#125;</div><div class="line">        cur.isEnd=true;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class Solution &#123;</div><div class="line">  public void dfs(TrieNode node,int x,int y,char[][]board,String path,List&lt;String&gt;res)&#123;</div><div class="line">        if(node!=null &amp;&amp; node.isEnd)&#123;</div><div class="line">            res.add(path);</div><div class="line">            node.isEnd=false;</div><div class="line">        &#125;</div><div class="line">        if(node==null)</div><div class="line">            return;</div><div class="line">        if(x&lt;0||x&gt;=board.length||y&lt;0||y&gt;=board[0].length||board[x][y]==&apos;*&apos;)</div><div class="line">            return;</div><div class="line">        char c = board[x][y];</div><div class="line">        board[x][y]=&apos;*&apos;;</div><div class="line">        dfs(node.children[c-&apos;a&apos;],x+1,y,board,path+c,res);</div><div class="line">        dfs(node.children[c-&apos;a&apos;],x-1,y,board,path+c,res);</div><div class="line">        dfs(node.children[c-&apos;a&apos;],x,y+1,board,path+c,res);</div><div class="line">        dfs(node.children[c-&apos;a&apos;],x,y-1,board,path+c,res);</div><div class="line">        board[x][y]=c;</div><div class="line">    &#125;</div><div class="line">    public List&lt;String&gt; findWords(char[][] board, String[] words) &#123;</div><div class="line">        List&lt;String&gt;res=new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        if(board.length==0||board[0].length==0||words.length==0)</div><div class="line">            return res;</div><div class="line">        int m = board.length,n=board[0].length;</div><div class="line">        Trie t = new Trie();</div><div class="line">        for(String str:words)</div><div class="line">            t.insert(str);</div><div class="line">        for(int i=0;i&lt;m;++i)&#123;</div><div class="line">            for(int j=0;j&lt;n;++j)&#123;</div><div class="line">                dfs(t.getRoot(),i,j,board,&quot;&quot;,res);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140 Word Break II"></a>140 Word Break II</h3><p>思路： 递归，然后用dp来memorize。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public List&lt;String&gt;wordBreak(String s,Set&lt;String&gt;sets,Map&lt;String,List&lt;String&gt;&gt;map)&#123;</div><div class="line">       if(map.containsKey(s))</div><div class="line">           return map.get(s);</div><div class="line">       List&lt;String&gt;res=new ArrayList&lt;&gt;();</div><div class="line">       if(s.isEmpty())&#123;</div><div class="line">           res.add(&quot;&quot;);</div><div class="line">           return res;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       int nn=s.length();</div><div class="line">       for(int i=1;i&lt;=nn;++i)&#123;</div><div class="line">           String sub=s.substring(0,i);</div><div class="line">           if(sets.contains(sub))&#123;</div><div class="line">               //List&lt;String&gt;tmp = wordBreak(s.substring(i),sets,map);</div><div class="line">               List&lt;String&gt;tmp = wordBreak(s.substring(i),sets,map);</div><div class="line">               for(String str:tmp)&#123;</div><div class="line">                   res.add(sub+(str.isEmpty()?&quot;&quot;:&quot; &quot;)+str);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       map.put(s,res);</div><div class="line">       return res;</div><div class="line">   &#125;</div><div class="line">   public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;</div><div class="line">       Set&lt;String&gt;sets=new HashSet&lt;&gt;(wordDict);</div><div class="line">       Map&lt;String,List&lt;String&gt;&gt;map=new HashMap&lt;&gt;();</div><div class="line">       return wordBreak(s,sets,map);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="51-N-Queens-amp-amp-52"><a href="#51-N-Queens-amp-amp-52" class="headerlink" title="51 N-Queens &amp;&amp; 52"></a>51 N-Queens &amp;&amp; 52</h3><p>思路： 一个数组记录每行要选的是哪个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public boolean check(int[]dp,int ind)&#123;</div><div class="line">        //check whether it has conflict with k-1 number</div><div class="line">        for(int i=0;i&lt;ind;++i)&#123;</div><div class="line">            if(dp[i]==dp[ind]||(ind-i)==Math.abs(dp[i]-dp[ind]))</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void dfs(int[]dp,List&lt;List&lt;String&gt;&gt;res,int ind,int n)&#123;</div><div class="line">        if(ind==n)&#123;</div><div class="line">            List&lt;String&gt;tmp=new ArrayList&lt;&gt;();</div><div class="line">            for(int ii=0;ii&lt;n;++ii)&#123;</div><div class="line">                char []ss = new char[n];</div><div class="line">                Arrays.fill(ss,&apos;.&apos;);</div><div class="line">                ss[dp[ii]]=&apos;Q&apos;;</div><div class="line">                tmp.add(String.valueOf(ss));</div><div class="line">            &#125;</div><div class="line">            res.add(tmp);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            dp[ind]=i;</div><div class="line">            if(check(dp,ind))</div><div class="line">                dfs(dp,res,ind+1,n);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        int []dp=new int[n];</div><div class="line">        Arrays.fill(dp,-1);</div><div class="line">        dfs(dp,res,0,n);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    //52 queens II</div><div class="line">    public void dfs(int n,int []dp,int[]res,int ind)&#123;</div><div class="line">        if(ind==n)&#123;</div><div class="line">            res[0]++;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            dp[ind]=i;</div><div class="line">            if(check(dp,ind))</div><div class="line">                dfs(n,dp,res,ind+1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int totalNQueens(int n) &#123;</div><div class="line">        int []dp=new int[n];</div><div class="line">        int []res=&#123;0&#125;;</div><div class="line">        Arrays.fill(dp,-1);</div><div class="line">        dfs(n,dp,res,0);</div><div class="line">        return res[0];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78 Subsets"></a>78 Subsets</h3><p>思路： bitmap， dfs， iterative</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        int n = nums.length,m=1&lt;&lt;n;</div><div class="line">        for(int i=0;i&lt;m;++i)</div><div class="line">            res.add(new ArrayList&lt;&gt;());</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            for(int j=0;j&lt;m;++j)&#123;</div><div class="line">                if(((j&gt;&gt;i)&amp;0x1)!=0)</div><div class="line">                    res.get(j).add(nums[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public void dfs78(List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;sub,int[]nums,int ind)&#123;</div><div class="line">        res.add(new ArrayList&lt;&gt;(sub));</div><div class="line">        for(int i=ind;i&lt;nums.length;++i)&#123;</div><div class="line">            sub.add(nums[i]);</div><div class="line">            dfs78(res,sub,nums,i+1);</div><div class="line">            sub.remove(sub.size()-1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        List&lt;Integer&gt;sub=new ArrayList&lt;&gt;();</div><div class="line">        dfs78(res,sub,nums,0);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        int n = nums.length;</div><div class="line">        if(n==0)</div><div class="line">            return res;</div><div class="line">        res.add(new ArrayList&lt;&gt;());</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            int size=res.size();</div><div class="line">            for(int j=0;j&lt;size;++j)&#123;</div><div class="line">                List&lt;Integer&gt;tmp = new ArrayList&lt;&gt;(res.get(j));</div><div class="line">                tmp.add(nums[i]);</div><div class="line">                res.add(tmp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="37-sudoku-solver"><a href="#37-sudoku-solver" class="headerlink" title="37 sudoku solver"></a>37 sudoku solver</h3><p>思路： 要用带boolean 的dfs去试探，注意的是判断合法的函数要对啊</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public boolean check(char[][]board,int ind)&#123;</div><div class="line">        //check row ind/9, col: ind%9, that square;</div><div class="line">        boolean []vis=new boolean[9];</div><div class="line">        int row = ind/9,col=ind%9;</div><div class="line">        for(int i=0;i&lt;9;++i)&#123;</div><div class="line">            if(board[row][i]==&apos;.&apos;)</div><div class="line">                continue;</div><div class="line">            if(vis[board[row][i]-&apos;1&apos;])</div><div class="line">                return false;</div><div class="line">            vis[board[row][i]-&apos;1&apos;]=true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Arrays.fill(vis,false);</div><div class="line">        for(int i=0;i&lt;9;++i)&#123;</div><div class="line">            if(board[i][col]==&apos;.&apos;)</div><div class="line">                continue;</div><div class="line">            if(vis[board[i][col]-&apos;1&apos;])</div><div class="line">                return false;</div><div class="line">            vis[board[i][col]-&apos;1&apos;]=true;</div><div class="line">        &#125;</div><div class="line">        Arrays.fill(vis,false);</div><div class="line"></div><div class="line">         row=row/3*3;</div><div class="line">        col=col/3*3;</div><div class="line">        for(int i=row;i&lt;row+3;++i)&#123;</div><div class="line">            for(int j=col;j&lt;col+3;++j)&#123;</div><div class="line">                if(board[i][j]==&apos;.&apos;)</div><div class="line">                    continue;</div><div class="line">                if(vis[board[i][j]-&apos;1&apos;])</div><div class="line">                    return false;</div><div class="line">                vis[board[i][j]-&apos;1&apos;]=true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public boolean dfs37(char[][]board,int ind)&#123;</div><div class="line">         if(ind==81)</div><div class="line">            return true;</div><div class="line">        if(board[ind/9][ind%9]!=&apos;.&apos;)&#123;</div><div class="line">            return dfs37(board,ind+1);</div><div class="line">        &#125;else&#123;</div><div class="line">            for(int i=1;i&lt;=9;++i)&#123;</div><div class="line">                board[ind/9][ind%9]=(char)(i+&apos;0&apos;);</div><div class="line">                if(check(board,ind) &amp;&amp; dfs37(board,ind+1) )&#123;</div><div class="line">                        return true;</div><div class="line">                &#125;</div><div class="line">                board[ind/9][ind%9]=&apos;.&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    public void solveSudoku(char[][] board) &#123;</div><div class="line">        dfs37(board,0);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93 Restore IP Addresses"></a>93 Restore IP Addresses</h3><p>思路： 一个一个检测，探测,leading zero的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public boolean valid(String s)&#123;</div><div class="line">        if(s.isEmpty()||s.length()&gt;3)</div><div class="line">            return false;</div><div class="line">        if(s.charAt(0)==&apos;0&apos; &amp;&amp; s.length()&gt;1)</div><div class="line">            return false;</div><div class="line">        return Integer.parseInt(s)&lt;=255;</div><div class="line">    &#125;</div><div class="line">    public void dfs93(List&lt;String&gt;res,String s,int index,List&lt;String&gt; path)&#123;</div><div class="line">        if(index==s.length() &amp;&amp; path.size()==4)&#123;</div><div class="line">            res.add(String.join(&quot;.&quot;,path));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if(path.size()&gt;4)</div><div class="line">            return;</div><div class="line">        for(int i=index+1;i&lt;=s.length();++i)&#123;</div><div class="line">            String sub=s.substring(index,i);</div><div class="line">            if(sub.length()&gt;3)</div><div class="line">                break;</div><div class="line">            if(valid(sub))&#123;</div><div class="line">                path.add(sub);</div><div class="line">                dfs93(res,s,i,path);</div><div class="line">                path.remove(path.size()-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</div><div class="line">        List&lt;String&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        if(s.length()&lt;4||s.length()&gt;12)</div><div class="line">            return res;</div><div class="line">        dfs93(res,s,0,new ArrayList&lt;&gt;());</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h3><p>思路： 可以提前打表也可以后面判断isPalindrome</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public void dfs1311(List&lt;List&lt;String&gt;&gt;res,List&lt;String&gt;path,String s,int ind,boolean[][]palindrome)&#123;</div><div class="line">        if(ind==s.length())&#123;</div><div class="line">            res.add(new ArrayList&lt;&gt;(path));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i=ind+1;i&lt;=s.length();++i)&#123;</div><div class="line">            if(palindrome[ind+1][i])&#123;</div><div class="line">                path.add(s.substring(ind,i));</div><div class="line">                dfs1311(res,path,s,i,palindrome);</div><div class="line">                path.remove(path.size()-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public List&lt;List&lt;String&gt;&gt;partition(String s)&#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        int m=s.length();</div><div class="line">        boolean [][]palindrome=new boolean[m+1][m+1];</div><div class="line">        palindrome[0][0]=true;</div><div class="line">        for(int i=1;i&lt;=m;++i)&#123;</div><div class="line">            palindrome[i][i]=true;</div><div class="line">            for(int j=i-1;j&gt;=1;--j)&#123;</div><div class="line">                if(s.charAt(j-1)==s.charAt(i-1) &amp;&amp;( j&gt;=i-2||palindrome[j+1][i-1]))&#123;</div><div class="line">                    palindrome[j][i]=true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dfs1311(res,new ArrayList&lt;&gt;(),s,0,palindrome);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    public boolean isPalindrome(String ss)&#123;</div><div class="line">        int begin=0,end=ss.length()-1;</div><div class="line">        char []sss=ss.toCharArray();</div><div class="line">        while(begin&lt;end)&#123;</div><div class="line">            if(sss[begin]!= sss[end])</div><div class="line">                return false;</div><div class="line">            begin++;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void dfs131(List&lt;List&lt;String&gt;&gt;res,List&lt;String&gt;path,String s,int index)&#123;</div><div class="line">        if(index==s.length())&#123;</div><div class="line">            res.add(new ArrayList&lt;&gt;(path));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        for(int i=index+1;i&lt;=s.length();++i)&#123;</div><div class="line">            String sub = s.substring(index,i);</div><div class="line">            if(isPalindrome(sub))&#123;</div><div class="line">                path.add(sub);</div><div class="line">                dfs131(res,path,s,i);</div><div class="line">                path.remove(path.size()-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</div><div class="line">        List&lt;List&lt;String&gt;&gt;res=new ArrayList&lt;&gt;();</div><div class="line">        dfs131(res,new ArrayList&lt;&gt;(),s,0);</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10 Regular Expression Matching"></a>10 Regular Expression Matching</h3><p>思路：递归或者是dp</p>
<pre><code>
public boolean isMatch(String s, String p) {
        if(p.isEmpty())
            return s.isEmpty();
        if(p.length()==1)
            return s.length()==1 &amp;&amp; (s.equals(p)||p.charAt(0)==&apos;.&apos;);
        if(s.isEmpty())
            return p.charAt(1)==&apos;*&apos; &amp;&amp; isMatch(s,p.substring(2));
        if(p.charAt(1)==&apos;*&apos;){
            //replace 0 or one or more than one
                       return isMatch(s,p.substring(2))||((s.charAt(0)==p.charAt(0)||p.charAt(0)==&apos;.&apos;)&amp;&amp;isMatch(s.substring(1),p));

        }else{
            return (s.charAt(0)==p.charAt(0)||p.charAt(0)==&apos;.&apos;)&amp;&amp;isMatch(s.substring(1),p.substring(1));
        }
    }

    public boolean isMatch(String s, String p) {
        if(p.isEmpty())
            return s.isEmpty();
        int m= s.length(),n=p.length();
        boolean [][]dp=new boolean[m+1][n+1];
        dp[0][0]=true;
        for(int i=2;i&lt;=n;++i)
            dp[0][i]=dp[0][i-2] &amp;&amp; p.charAt(i-1)==&apos;*&apos;;
        for(int i=1;i&lt;=m;++i){
            if(i==1)
                dp[i][1]=(s.charAt(i-1)==p.charAt(0))||p.charAt(0)==&apos;.&apos;;
            for(int j=2;j&lt;=n;++j){
                if(p.charAt(j-1)==&apos;*&apos;){
                    dp[i][j]=dp[i][j-2]||(s.charAt(i-1)==p.charAt(j-2)||p.charAt(j-2)==&apos;.&apos;) &amp;&amp; dp[i-1][j];
                }else{
                    dp[i][j]=(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)==&apos;.&apos;)&amp;&amp;dp[i-1][j-1];
                }
            }
        }
        return dp[m][n];
    }
</code></pre><hr>
<h1 id="Expectations"><a href="#Expectations" class="headerlink" title="Expectations"></a>Expectations</h1><hr>
<ul>
<li>把dp里的滚动数组搞清楚，节省空间</li>
<li>探索下啤酒鱼怎么做。周末试了试煮鱼，好久没吃过鱼了，表示怀念。</li>
</ul>
<p><img src="https://lh3.googleusercontent.com/rvalQTz4G55AyZ01zNTErlmRt-NFFFVGN64Rk6QPzUQ4WG98DOW2s1lqcnnijp-CwT8nGfLWvOe7nPvWEaLxvCwUiE79XtI0OzRe8MJhymATDSYj2CUsgHr5KsBOgkGBVNOBV3aLOw" alt="Stanford Univ"></p>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stackQuestions]]></title>
      <url>/2017/07/16/stackQuestions/</url>
      <content type="html"><![CDATA[<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><hr>
<a id="more"></a>
<ul>
<li>155 Min Stack</li>
<li>42 Trapping Rain Water</li>
<li>150 Evaluate Reverse Polish Notation</li>
<li>173 Binary Search Tree Iterator</li>
<li>85 Maximal Rectangle</li>
<li>232 Implement Queue using Stacks</li>
<li>84 Largest Rectangle in Histogram</li>
<li>71 Simplify Path</li>
<li>94 Binary Tree Inorder Traversal</li>
<li>341     Flatten Nested List Iterator</li>
<li>225     Binary Tree Postorder Traversal</li>
<li>394 Decode String</li>
<li>255    Verify Preorder Sequence in Binary Search Tree</li>
<li>439 Ternary Expression Parser</li>
<li>496 Next Greater Element I</li>
<li>503 Next Greater Element II</li>
<li>316 Remove Duplicate Letters</li>
<li>227 Basic Calculator II</li>
<li>224 Basic Calculator</li>
<li>394 Decode String</li>
<li>385 Mini Parser</li>
<li>636 Exclusive Time of Functions</li>
<li>331 Verify Preorder Serialization of a Binary Tree</li>
<li>456 132 Pattern</li>
</ul>
<h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155 Min Stack"></a>155 Min Stack</h3><p>思路： 两个栈的很容易写出来，但是要求一个栈来实现呢？</p>
<ul>
<li>一个栈存gap，一个数字存最小值,用long</li>
<li>一个栈，一个数字存最小值，当遇到最小值时，存两次</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">public class MinStack &#123;</div><div class="line"></div><div class="line">     Stack&lt;Long&gt;stk=null;</div><div class="line">    long minVal;</div><div class="line">    public MinStack() &#123;</div><div class="line">        stk=new Stack&lt;&gt;();</div><div class="line">        minVal=Long.MAX_VALUE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void push(int x) &#123;</div><div class="line">        if(stk.isEmpty())&#123;</div><div class="line">            stk.push(0l);</div><div class="line">            minVal=(long)x;</div><div class="line">        &#125;else&#123;</div><div class="line">            stk.push(x-minVal);</div><div class="line">            minVal=Math.min(minVal,x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void pop() &#123;</div><div class="line">        long val = stk.pop();</div><div class="line">        if(val&lt;0)//pay attention to this </div><div class="line">            minVal=(-val+minVal);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	//pay attention to this </div><div class="line">    public int top() &#123;</div><div class="line">        if(stk.peek()&lt;0)</div><div class="line">            return (int)minVal;</div><div class="line">        else</div><div class="line">            return (int)(minVal+stk.peek());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getMin() &#123;</div><div class="line">        return (int)minVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//wrong answer if no equals in x&lt;=minVal</div><div class="line">public class MinStack &#123;</div><div class="line"></div><div class="line">    Stack&lt;Integer&gt;stk=null;</div><div class="line">    private int minVal;</div><div class="line">    /** initialize your data structure here. */</div><div class="line">    public MinStack() &#123;</div><div class="line">        minVal=Integer.MAX_VALUE;</div><div class="line">        stk=new Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void push(int x) &#123;</div><div class="line">        if(x&lt;=minVal)&#123;</div><div class="line">            stk.push(minVal);</div><div class="line">            minVal=x;</div><div class="line">        &#125;</div><div class="line">        stk.push(x);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void pop() &#123;</div><div class="line">        if(stk.pop()==minVal)&#123;</div><div class="line">            minVal=stk.pop();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int top() &#123;</div><div class="line">        return stk.peek();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int getMin() &#123;</div><div class="line">        return minVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="42-Traping-rain-water"><a href="#42-Traping-rain-water" class="headerlink" title="42 Traping rain water"></a>42 Traping rain water</h3><p>思路： 单调栈来实现</p>
<ul>
<li>单调栈，和84题非常像</li>
<li>两指针</li>
<li>左右两数组记录最大值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public int trap(int[] height) &#123;</div><div class="line">        int n = height.length;</div><div class="line">        Stack&lt;Integer&gt; stk=new Stack&lt;&gt;();</div><div class="line">        int area=0;</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            while(!stk.isEmpty() &amp;&amp; height[stk.peek()]&lt;height[i])&#123;</div><div class="line">                int h = height[stk.pop()];</div><div class="line">                int h1=stk.isEmpty()?0:height[stk.peek()];</div><div class="line">                int w = stk.isEmpty()?i:i-1-stk.peek();</div><div class="line">                area+=Math.max((Math.min(h1,height[i])-h)*w,0);</div><div class="line">            &#125;</div><div class="line">            stk.push(i);</div><div class="line">        &#125;</div><div class="line">        return area;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150 Evaluate Reverse Polish Notation"></a>150 Evaluate Reverse Polish Notation</h3><p>思路： 栈和递归来实现</p>
<ul>
<li>栈</li>
<li>递归</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public int evalRPN(String[] tokens) &#123;</div><div class="line">         Stack&lt;String&gt;stk=new Stack&lt;&gt;();</div><div class="line">        for(String token:tokens)&#123;</div><div class="line">            if(token.equals(&quot;+&quot;)||token.equals(&quot;-&quot;)||token.equals(&quot;*&quot;)||token.equals(&quot;/&quot;))&#123;</div><div class="line">                if(stk.size()&lt;2)</div><div class="line">                    break;</div><div class="line">                int val1= Integer.parseInt(stk.pop());</div><div class="line">                int val2 = Integer.parseInt(stk.pop());</div><div class="line">                if(token.equals(&quot;+&quot;))</div><div class="line">                    stk.push(String.valueOf(val2+val1));</div><div class="line">                else if(token.equals(&quot;-&quot;))</div><div class="line">                    stk.push(String.valueOf(val2-val1));</div><div class="line">                else if(token.equals(&quot;*&quot;))</div><div class="line">                    stk.push(String.valueOf(val2*val1));</div><div class="line">                else</div><div class="line">                    stk.push(String.valueOf(val2/val1));</div><div class="line"></div><div class="line">            &#125;else</div><div class="line">                stk.push(token);</div><div class="line">        &#125;</div><div class="line">        if(!stk.isEmpty())</div><div class="line">            return Integer.parseInt(stk.peek());</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    //很奇怪，如果用li， start ，end会跪。</div><div class="line">    public int eval(List&lt;String&gt;li)&#123;</div><div class="line">        int n=li.size();</div><div class="line">        String str=li.get(n-1);</div><div class="line">        li.remove(n-1);</div><div class="line">        if(str.equals(&quot;+&quot;)||str.equals(&quot;-&quot;)||str.equals(&quot;/&quot;)||str.equals(&quot;*&quot;))&#123;</div><div class="line">            int r1=eval(li);</div><div class="line">            int r2=eval(li);</div><div class="line">            if(str.equals(&quot;+&quot;))</div><div class="line">                return r1+r2;</div><div class="line">            else if(str.equals(&quot;-&quot;))</div><div class="line">                return r2-r1;</div><div class="line">            else if(str.equals(&quot;*&quot;))</div><div class="line">                return r2*r1;</div><div class="line">            else</div><div class="line">                return r2/r1;</div><div class="line">        &#125;</div><div class="line">        return Integer.valueOf(str);</div><div class="line">    &#125;</div><div class="line">    public int evalRPN(String []tokens)&#123;</div><div class="line">        int n=tokens.length;</div><div class="line">        List&lt;String&gt;li=new ArrayList&lt;&gt;(Arrays.asList(tokens));</div><div class="line">        return eval(li);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173 Binary Search Tree Iterator"></a>173 Binary Search Tree Iterator</h3><p>思路： 其实就是stack的中序遍历，当然你可以先走一遍中序遍历，然后把所有的值都存到list里，但是这样的话非常耗space，常见的优化时lazy load</p>
<ul>
<li>中序遍历走一遍，存下所有的值</li>
<li>lazy load，必要的时候才继续载入值,记住 中序遍历是pop的，后序遍历是peek的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class BSTIterator &#123;</div><div class="line"></div><div class="line">   public Stack&lt;TreeNode&gt; stk=null;</div><div class="line">    TreeNode cur=null;</div><div class="line">    public BSTIterator(TreeNode root) &#123;</div><div class="line">        cur=root;</div><div class="line">        stk=new Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** @return whether we have a next smallest number */</div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        return !stk.isEmpty()||cur!=null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** @return the next smallest number */</div><div class="line">    public int next() &#123;</div><div class="line">       int val=0;</div><div class="line">        while(cur!=null)&#123;</div><div class="line">            stk.push(cur);</div><div class="line">            cur=cur.left;</div><div class="line">        &#125;</div><div class="line">        cur=stk.pop();</div><div class="line">        val=cur.val;</div><div class="line">        cur=cur.right;</div><div class="line">        return val;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="84-Largest-Rectangle-in-Histogram-amp-amp-85-Maximal-Rectangle-以及trapping-rain-water-是姊妹题"><a href="#84-Largest-Rectangle-in-Histogram-amp-amp-85-Maximal-Rectangle-以及trapping-rain-water-是姊妹题" class="headerlink" title="84 Largest Rectangle in Histogram &amp;&amp; 85 Maximal Rectangle 以及trapping rain water 是姊妹题"></a>84 Largest Rectangle in Histogram &amp;&amp; 85 Maximal Rectangle 以及trapping rain water 是姊妹题</h3><p>思路：单调栈和动态规划</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//84 largest rectangle in histgram</div><div class="line">public int largestRectangleArea(int[] heights) &#123;</div><div class="line">        int n = heights.length;</div><div class="line">        Stack&lt;Integer&gt;stk=new Stack&lt;&gt;();</div><div class="line">        int maxArea=0;</div><div class="line">        for(int i=0;i&lt;=n;++i)&#123;</div><div class="line">            int height=i&lt;n?heights[i]:0;</div><div class="line">            while(!stk.isEmpty() &amp;&amp; heights[stk.peek()]&gt;height)&#123;</div><div class="line">                int h = heights[stk.pop()];</div><div class="line">                int w = stk.isEmpty()?i:i-stk.peek()-1;//i is not in the area</div><div class="line">                maxArea=Math.max(maxArea,h*w);</div><div class="line">            &#125;</div><div class="line">            stk.push(i);</div><div class="line">        &#125;</div><div class="line">        return maxArea;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //85 maximal rectangle</div><div class="line">    public int maximalRectangle(char[][] matrix) &#123;</div><div class="line">        if(matrix.length==0||matrix[0].length==0)</div><div class="line">            return 0;</div><div class="line">        int m = matrix.length,n=matrix[0].length;</div><div class="line">        int []dp=new int[n];</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            dp[i]=matrix[0][i]==&apos;1&apos;?1:0;</div><div class="line">        &#125;</div><div class="line">        int maxArea=largestRectangleArea(dp);</div><div class="line">        for(int i=1;i&lt;m;++i)&#123;</div><div class="line">            for(int j=0;j&lt;n;++j)&#123;</div><div class="line">                dp[j]=matrix[i][j]==&apos;0&apos;?0:dp[j]+1;</div><div class="line">            &#125;</div><div class="line">            maxArea=Math.max(maxArea,largestRectangleArea(dp));</div><div class="line">        &#125;</div><div class="line">        return maxArea;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232 Implement Queue using Stacks"></a>232 Implement Queue using Stacks</h3><p>思路： 两stack，两stack 是不平等的关系， stack2是优先级比较高的。</p>
<ul>
<li>two stack, push is O(1), others are O(N)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class MyQueue &#123;</div><div class="line"></div><div class="line">    //two stack, uneven</div><div class="line">    public Stack&lt;Integer&gt; stk=null;//primary stack;</div><div class="line">    public Stack&lt;Integer&gt;stk1=null;</div><div class="line">    /** Initialize your data structure here. */</div><div class="line">    public MyQueue() &#123;</div><div class="line">        stk=new Stack&lt;&gt;();</div><div class="line">        stk1=new Stack&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Push element x to the back of queue. */</div><div class="line">    public void push(int x) &#123;</div><div class="line">        stk.push(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Removes the element from in front of queue and returns that element. */</div><div class="line">    public int pop() &#123;</div><div class="line">        if(!stk1.isEmpty())</div><div class="line">            return stk1.pop();</div><div class="line">        while(!stk.isEmpty())</div><div class="line">            stk1.push(stk.pop());</div><div class="line">        return stk1.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Get the front element. */</div><div class="line">    public int peek() &#123;</div><div class="line">        if(!stk1.isEmpty())</div><div class="line">            return stk1.peek();</div><div class="line">        while(!stk.isEmpty())</div><div class="line">            stk1.push(stk.pop());</div><div class="line">        return stk1.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Returns whether the queue is empty. */</div><div class="line">    public boolean empty() &#123;</div><div class="line">        return stk.isEmpty() &amp;&amp; stk1.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a>225. Implement Stack using Queues</h3><p> 思路： 两queue，相等的地位，每次都是剩下一个元素，剩下的push到另一外一个queue</p>
<ul>
<li>两个queue， push是o(1)， 其他是o(n)</li>
<li>一个queue，push是o(n)，其他是o(1)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">public class MyStackOneQueue &#123;</div><div class="line">    /** Initialize your data structure here. */</div><div class="line"></div><div class="line">    private Queue&lt;Integer&gt; q=null;</div><div class="line">    public MyStackOneQueue() &#123;</div><div class="line">        q=new LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Push element x onto stack. */</div><div class="line">    public void push(int x) &#123;</div><div class="line">        q.offer(x);</div><div class="line">        for(int i=0;i&lt;q.size()-1;++i)&#123;</div><div class="line">            q.offer(q.poll());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Removes the element on top of the stack and returns that element. */</div><div class="line">    public int pop() &#123;</div><div class="line">        return q.poll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Get the top element. */</div><div class="line">    public int top() &#123;</div><div class="line">        return q.peek();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Returns whether the stack is empty. */</div><div class="line">    public boolean empty() &#123;</div><div class="line">        return q.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class MyStack &#123;</div><div class="line"></div><div class="line">      //two queue even</div><div class="line">    Queue&lt;Integer&gt; q=null;</div><div class="line">    Queue&lt;Integer&gt;q1=null;</div><div class="line"></div><div class="line">    /** Initialize your data structure here. */</div><div class="line">    public MyStack() &#123;</div><div class="line">        q=new LinkedList&lt;&gt;();</div><div class="line">        q1=new LinkedList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Push element x onto stack. */</div><div class="line">    public void push(int x) &#123;</div><div class="line">        q.offer(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Removes the element on top of the stack and returns that element. */</div><div class="line">    public int pop() &#123;</div><div class="line">        int val=0;</div><div class="line">        if(!q.isEmpty())&#123;</div><div class="line">            while(q.size()&gt;1)&#123;</div><div class="line">                q1.offer(q.poll());</div><div class="line">            &#125;</div><div class="line">            val=q.poll();</div><div class="line">        &#125;else&#123;</div><div class="line">            while(q1.size()&gt;1)&#123;</div><div class="line">                q.offer(q1.poll());</div><div class="line">            &#125;</div><div class="line">            val=q1.poll();</div><div class="line">        &#125;</div><div class="line">        return val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Get the top element. */</div><div class="line">    public int top() &#123;</div><div class="line">        int val=0;</div><div class="line">        if(!q.isEmpty())&#123;</div><div class="line">            while(q.size()&gt;1)&#123;</div><div class="line">                q1.offer(q.poll());</div><div class="line">            &#125;</div><div class="line">            val=q.poll();</div><div class="line">            q1.offer(val);</div><div class="line">        &#125;else&#123;</div><div class="line">            while(q1.size()&gt;1)&#123;</div><div class="line">                q.offer(q1.poll());</div><div class="line">            &#125;</div><div class="line">            val=q1.poll();</div><div class="line">            q.offer(val);</div><div class="line">        &#125;</div><div class="line">        return val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Returns whether the stack is empty. */</div><div class="line">    public boolean empty() &#123;</div><div class="line">        return q.isEmpty() &amp;&amp; q1.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a>71. Simplify Path</h3><p>思路： 切割， !stk.isEmpty &amp;&amp; str==”..” 出栈, str!=’.’ &amp;&amp; str!=’..’ str!=”” 就加到stack里,最后别忘了加上 “/”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public String simplifyPath(String path) &#123;</div><div class="line">        String []paths = path.split(&quot;/&quot;);</div><div class="line">        Stack&lt;String&gt;stk=new Stack&lt;&gt;();</div><div class="line">        for(String str:paths)&#123;</div><div class="line">            if(!stk.isEmpty() &amp;&amp; str.equals(&quot;..&quot;))&#123;</div><div class="line">                stk.pop();</div><div class="line">            &#125;else if(!str.equals(&quot;.&quot;) &amp;&amp; str.length()!=0 &amp;&amp; !str.equals(&quot;..&quot;))</div><div class="line">                stk.push(str);</div><div class="line">        &#125;</div><div class="line">        String res = String.join(&quot;/&quot;,stk);</div><div class="line">        return &quot;/&quot;+res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="94-binary-tree-inorder-traversal"><a href="#94-binary-tree-inorder-traversal" class="headerlink" title="94 binary tree inorder traversal"></a>94 binary tree inorder traversal</h3><p>思路： 掌握三种，递归，stack，莫里斯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt;res = new ArrayList&lt;&gt;();</div><div class="line">        TreeNode cur = root;</div><div class="line">        Stack&lt;TreeNode&gt;stk=new Stack&lt;TreeNode&gt;();</div><div class="line">        while(cur!=null||!stk.isEmpty())&#123;</div><div class="line">            while(cur!=null)&#123;</div><div class="line">                stk.push(cur);</div><div class="line">                cur=cur.left;</div><div class="line">            &#125;</div><div class="line">            cur=stk.pop();</div><div class="line">            res.add(cur.val);</div><div class="line">            cur=cur.right;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="341-flatten-nested-list-iterator"><a href="#341-flatten-nested-list-iterator" class="headerlink" title="341 flatten nested list iterator"></a>341 flatten nested list iterator</h3><p>思路： 可以一次性遍历完，然后再遍历，但是这样的话空间复杂度太高</p>
<ul>
<li>一次性遍历完</li>
<li>lazy load，需要的时候才遍历，用到栈, queue就不行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class NestedIterator implements Iterator&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">    private Stack&lt;NestedInteger&gt; stk=null;</div><div class="line">    public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;</div><div class="line">        stk=new Stack&lt;&gt;();</div><div class="line">        int n=nestedList.size();</div><div class="line">        for(int i=n-1;i&gt;=0;--i)&#123;</div><div class="line">            if(!nestedList.get(i).isInteger())&#123;</div><div class="line">                if(nestedList.get(i).getList().isEmpty())</div><div class="line">                    continue;</div><div class="line">            &#125;</div><div class="line">            stk.push(nestedList.get(i));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Integer next() &#123;</div><div class="line">        return stk.pop().getInteger();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        while(!stk.isEmpty() &amp;&amp; !stk.peek().isInteger())&#123;</div><div class="line">            NestedInteger top=stk.pop();</div><div class="line">            if(top.isInteger())&#123;</div><div class="line">                stk.push(top);</div><div class="line">                System.out.println(&quot;a&quot;);</div><div class="line">                break;</div><div class="line">            &#125;else&#123;</div><div class="line">                List&lt;NestedInteger&gt;nestedList=top.getList();</div><div class="line">                int n=nestedList.size();</div><div class="line">                for(int i=n-1;i&gt;=0;--i)&#123;</div><div class="line">                    if(!nestedList.get(i).isInteger())&#123;</div><div class="line">                        if(nestedList.get(i).getList().isEmpty())</div><div class="line">                            continue;</div><div class="line">                    &#125;</div><div class="line">                    stk.push(nestedList.get(i));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return !stk.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145 Binary Tree Postorder Traversal"></a>145 Binary Tree Postorder Traversal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">TreeNode pre =null;</div><div class="line">   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</div><div class="line">       List&lt;Integer&gt;res=new ArrayList&lt;&gt;();</div><div class="line">       if(root==null)</div><div class="line">           return res;</div><div class="line">       Stack&lt;TreeNode&gt;stk=new Stack&lt;&gt;();</div><div class="line">       TreeNode curr = root;</div><div class="line">       while (!stk.isEmpty() || curr != null) &#123;</div><div class="line">           while(curr!=null)&#123;</div><div class="line">               stk.push(curr);</div><div class="line">               curr=curr.left;</div><div class="line">           &#125;</div><div class="line">           curr=stk.peek();</div><div class="line"></div><div class="line">           if(curr.right!=null &amp;&amp; curr.right!=pre)&#123;//没有被访问</div><div class="line">               curr=curr.right;</div><div class="line">           &#125;else&#123;</div><div class="line">               res.add(curr.val);</div><div class="line">               pre=curr;</div><div class="line">               stk.pop();</div><div class="line">               curr=null;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return res;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="439-Ternary-Expression-Parser"><a href="#439-Ternary-Expression-Parser" class="headerlink" title="439. Ternary Expression Parser"></a>439. Ternary Expression Parser</h3><p>思路： 反着入栈,递归容易爆</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public String parseTernary(String expression) &#123;</div><div class="line">        Stack&lt;Character&gt;stk=new Stack&lt;&gt;();</div><div class="line">        char []ss=expression.toCharArray();</div><div class="line">        //when finding ?, it is your chance</div><div class="line">        int n = ss.length,i=n-1;</div><div class="line">        while(i&gt;=0)&#123;</div><div class="line">            if(ss[i]!=&apos;?&apos; &amp;&amp; ss[i]!=&apos;:&apos;)</div><div class="line">                stk.push(ss[i]);</div><div class="line">            else if(ss[i]==&apos;?&apos;)&#123;</div><div class="line">                char c1= stk.pop();</div><div class="line">                char c2=stk.pop();</div><div class="line">                stk.push(ss[i-1]==&apos;T&apos;?c1:c2);</div><div class="line">                i-=2;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        return String.valueOf(stk.peek());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="496-next-greater-element-I"><a href="#496-next-greater-element-I" class="headerlink" title="496 next greater element I"></a>496 next greater element I</h3><p>思路： stack专门找第一个比它大的元素。递减，然后找到一个大的，那么就出栈，这些出栈的元素的最近大的元素都是它。在这里我们用hashmap建立联系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int[] nextGreaterElement(int[] findNums, int[] nums) &#123;</div><div class="line">         int n = findNums.length,m=nums.length;</div><div class="line">        int []res=new int[n];</div><div class="line">        //先一个map建起来</div><div class="line">        Map&lt;Integer,Integer&gt;map=new HashMap&lt;&gt;();</div><div class="line">        Stack&lt;Integer&gt;stk=new Stack&lt;&gt;();</div><div class="line">        for(int i=0;i&lt;m;++i)&#123;</div><div class="line">            while(!stk.isEmpty() &amp;&amp; stk.peek()&lt;nums[i])&#123;</div><div class="line">                map.put(stk.pop(),nums[i]);</div><div class="line">            &#125;</div><div class="line">            stk.push(nums[i]);</div><div class="line">        &#125;</div><div class="line">        Arrays.fill(res,-1);</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            if(map.containsKey(findNums[i]))</div><div class="line">                res[i]=map.get(findNums[i]);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="503-Next-Greater-Element-II"><a href="#503-Next-Greater-Element-II" class="headerlink" title="503. Next Greater Element II"></a>503. Next Greater Element II</h3><p>思路： 和上题差不多，环状的话走两遍，2*n，然后用mod，这个不需要hashmap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public int[] nextGreaterElements(int[] nums) &#123;</div><div class="line">        int n=nums.length;</div><div class="line">        int []res=new int[n];</div><div class="line">        Arrays.fill(res,-1);</div><div class="line">        Stack&lt;Integer&gt;stk=new Stack&lt;&gt;();</div><div class="line">        for(int i=0;i&lt;2*n;++i)&#123;</div><div class="line">            while(!stk.isEmpty() &amp;&amp; nums[i%n]&gt;nums[stk.peek()])&#123;</div><div class="line">                res[stk.pop()]=nums[i%n];</div><div class="line">            &#125;</div><div class="line">            //if(i&lt;n)</div><div class="line">            stk.push(i%n);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="316-Remove-Duplicate-Letters"><a href="#316-Remove-Duplicate-Letters" class="headerlink" title="316.Remove Duplicate Letters"></a>316.Remove Duplicate Letters</h3><p>思路： 先统计26个char的分布，同时记住哪些被访问过，用stack装。只有当后面还有这个字符，且这个字符大于或等于当前字符才可以替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public String removeDuplicateLetters(String s) &#123;</div><div class="line">        int []cnt=new int[26];</div><div class="line">        char []ss=s.toCharArray();</div><div class="line">        for(char c:ss)</div><div class="line">            cnt[c-&apos;a&apos;]++;</div><div class="line">        Stack&lt;Character&gt;stk=new Stack&lt;&gt;();</div><div class="line">        boolean []vis = new boolean[26];</div><div class="line">        for(char c:ss)&#123;</div><div class="line">            --cnt[c-&apos;a&apos;];</div><div class="line">            if(vis[c-&apos;a&apos;])</div><div class="line">                continue;</div><div class="line">            while(!stk.isEmpty() &amp;&amp; cnt[stk.peek()-&apos;a&apos;]&gt;0 &amp;&amp; stk.peek()&gt;=c)&#123;</div><div class="line">                char cc = stk.pop();</div><div class="line">                vis[cc-&apos;a&apos;]=false;</div><div class="line">            &#125;</div><div class="line">            stk.push(c);</div><div class="line">            vis[c-&apos;a&apos;]=true;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        while(!stk.isEmpty())&#123;</div><div class="line">            sb.append(stk.pop());</div><div class="line">        &#125;</div><div class="line">        sb.reverse();</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="227-Basic-Calculator-II"><a href="#227-Basic-Calculator-II" class="headerlink" title="227.Basic Calculator II"></a>227.Basic Calculator II</h3><p>思路： 笨一点可以用stk装，以后可以优化，令我非常惊奇的是如何做到： 计算完当前的数字，此时符号是它前面的“+ - * ／”</p>
<ul>
<li>stk</li>
<li>without stk</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public int calculate(String s) &#123;</div><div class="line">         int n=s.length();</div><div class="line">        char []ss=s.toCharArray();</div><div class="line">        Stack&lt;Integer&gt;stk=new Stack&lt;&gt;();</div><div class="line">        int num =0;</div><div class="line">        char sign =&apos;+&apos;;</div><div class="line">        int ans=0,prev=0;</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            if(Character.isDigit(ss[i]))&#123;</div><div class="line">                num=10*num+(ss[i]-&apos;0&apos;);</div><div class="line">            &#125;</div><div class="line">            if((!Character.isDigit(ss[i]) &amp;&amp; ss[i]!=&apos; &apos;)|| i==n-1 )&#123;</div><div class="line">                if(sign==&apos;-&apos;)&#123;</div><div class="line">                    ans+=prev;</div><div class="line">                    prev=-num;</div><div class="line">                &#125;</div><div class="line">                else if(sign==&apos;+&apos;)&#123;</div><div class="line">                    ans+=prev;</div><div class="line">                    prev=num;</div><div class="line">                &#125;</div><div class="line">                else if(sign==&apos;*&apos;)&#123;</div><div class="line">                    prev=prev*num;</div><div class="line">                &#125;else if(sign==&apos;/&apos;)&#123;</div><div class="line">                    prev=prev/num;</div><div class="line">                &#125;</div><div class="line">                sign=ss[i];//放在后面真是很巧妙啊,就省得向我这样蛮干了。</div><div class="line">                num=0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return ans+=prev;</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">    public int calculate(String s) &#123;</div><div class="line">	    int len;</div><div class="line">	    if(s==null || (len = s.length())==0) return 0;</div><div class="line">	    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</div><div class="line">	    int num = 0;</div><div class="line">	    char sign = &apos;+&apos;;</div><div class="line">	    for(int i=0;i&lt;len;i++)&#123;</div><div class="line">	        if(Character.isDigit(s.charAt(i)))&#123;</div><div class="line">	            num = num*10+s.charAt(i)-&apos;0&apos;;</div><div class="line">	        &#125;</div><div class="line">	        if((!Character.isDigit(s.charAt(i)) &amp;&amp;&apos; &apos;!=s.charAt(i)) || i==len-1)&#123;</div><div class="line">	            if(sign==&apos;-&apos;)&#123;</div><div class="line">	                stack.push(-num);</div><div class="line">	            &#125;</div><div class="line">	            if(sign==&apos;+&apos;)&#123;</div><div class="line">	                stack.push(num);</div><div class="line">	            &#125;</div><div class="line">	            if(sign==&apos;*&apos;)&#123;</div><div class="line">	                stack.push(stack.pop()*num);</div><div class="line">	            &#125;</div><div class="line">	            if(sign==&apos;/&apos;)&#123;</div><div class="line">	                stack.push(stack.pop()/num);</div><div class="line">	            &#125;</div><div class="line">	            sign = s.charAt(i);</div><div class="line">	            num = 0;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	</div><div class="line">	    int re = 0;</div><div class="line">	    for(int i:stack)&#123;</div><div class="line">	        re += i;</div><div class="line">	    &#125;</div><div class="line">	    return re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="224-Basic-Calculator"><a href="#224-Basic-Calculator" class="headerlink" title="224. Basic Calculator"></a>224. Basic Calculator</h3><p>思路： 每遇到(，就把res入栈，符号入栈,遇到) 就弹出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public int calculate(String s) &#123;</div><div class="line">        int n = s.length();</div><div class="line">        char []ss=s.toCharArray();</div><div class="line">        Stack&lt;Integer&gt;stk=new Stack&lt;&gt;();</div><div class="line">        int sign=1,res=0,num=0;</div><div class="line">        for(int i=0;i&lt;n;++i)&#123;</div><div class="line">            if(i&lt;n &amp;&amp; Character.isDigit(ss[i]))&#123;</div><div class="line">                num=10*num+(ss[i]-&apos;0&apos;);</div><div class="line">            &#125;</div><div class="line">            if((!Character.isDigit(ss[i]) &amp;&amp; ss[i]!=&apos; &apos;)||i==n-1)&#123;</div><div class="line">                if(ss[i]==&apos;+&apos;)&#123;</div><div class="line">                    res+=sign*num;</div><div class="line">                    sign=1;</div><div class="line">                    num=0;</div><div class="line">                &#125;</div><div class="line">                else if(ss[i]==&apos;-&apos;)&#123;</div><div class="line">                    res+=sign*num;</div><div class="line">                    sign=-1;</div><div class="line">                    num=0;</div><div class="line">                &#125;else if(ss[i]==&apos;(&apos;)&#123;</div><div class="line">                    stk.push(res);</div><div class="line">                    stk.push(sign);</div><div class="line">                    sign=1;</div><div class="line">                    res=0;</div><div class="line">                    num=0;</div><div class="line">                &#125;else if(ss[i]==&apos;)&apos;)&#123;</div><div class="line">                    res+=num*sign;</div><div class="line">                    res*=stk.pop();</div><div class="line">                    res+=stk.pop();</div><div class="line">                    sign=1;</div><div class="line">                    num=0;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res+=sign*num;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="385-Mini-Parser"><a href="#385-Mini-Parser" class="headerlink" title="385. Mini Parser"></a>385. Mini Parser</h3><p>思路： 遇到做括号，就存到栈里，遇到右括号就先pop，然后再加上当前的.</p>
<ul>
<li>recursive way</li>
<li>stk way</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public NestedInteger deserialize(String s) &#123;</div><div class="line">        if(s.isEmpty())</div><div class="line">            return new NestedInteger();</div><div class="line">        if(s.charAt(0)!=&apos;[&apos;)</div><div class="line">            return new NestedInteger(Integer.parseInt(s));</div><div class="line">        Stack&lt;NestedInteger&gt;stk=new Stack&lt;&gt;();</div><div class="line">        NestedInteger res = new NestedInteger();</div><div class="line">        int ind=1,n=s.length(),sign=1;</div><div class="line">        char []ss=s.toCharArray();</div><div class="line">        while(ind&lt;n-1) &#123;</div><div class="line">            if(ss[ind]==&apos;-&apos;)&#123;</div><div class="line">                ind++;</div><div class="line">                sign=-1;</div><div class="line">            &#125;</div><div class="line">            if(ind&lt;n-1 &amp;&amp; Character.isDigit(ss[ind]))&#123;</div><div class="line">                int num =0;</div><div class="line">                while(ind&lt;n-1 &amp;&amp; Character.isDigit(ss[ind]))&#123;</div><div class="line">                    num=10*num+(ss[ind++]-&apos;0&apos;);</div><div class="line">                &#125;</div><div class="line">                res.add(new NestedInteger(sign*num));</div><div class="line">                sign=1;</div><div class="line">            &#125;</div><div class="line">            if(ind&lt;n-1 &amp;&amp; ss[ind]==&apos;,&apos;)&#123;</div><div class="line">                ind++;</div><div class="line">            &#125;</div><div class="line">            if(ind&lt;n-1 &amp;&amp; ss[ind]==&apos;[&apos;)&#123;</div><div class="line">                stk.add(res);</div><div class="line">                res = new NestedInteger();</div><div class="line">                ind++;</div><div class="line">            &#125;</div><div class="line">            if(ind&lt;n-1 &amp;&amp; ss[ind]==&apos;]&apos; &amp;&amp; !stk.isEmpty())&#123;</div><div class="line">                NestedInteger tmp = stk.pop();</div><div class="line">                tmp.add(res);</div><div class="line">                res=tmp;</div><div class="line">                ind++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="394-Decode-String"><a href="#394-Decode-String" class="headerlink" title="394. Decode String"></a>394. Decode String</h3><p>思路： 两个stk，一个专门存数字，一个存字符串，遇到左括号就存到栈里，遇到右括号就从两个栈里弹出内容.</p>
<ul>
<li>recursive way</li>
<li>stk way</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public String decodeString(String s) &#123;</div><div class="line">        int ind=0,n = s.length();</div><div class="line">        char []ss = s.toCharArray();</div><div class="line">        Stack&lt;Integer&gt;num=new Stack&lt;&gt;();</div><div class="line">        Stack&lt;String&gt;stk=new Stack&lt;&gt;();</div><div class="line">        StringBuilder sb = new StringBuilder();</div><div class="line">        while(ind&lt;n)&#123;</div><div class="line">            if(Character.isDigit(ss[ind]))&#123;</div><div class="line">                int number = 0;</div><div class="line">                while(ind&lt;n &amp;&amp; Character.isDigit(ss[ind]))&#123;</div><div class="line">                    number=10*number+(ss[ind++]-&apos;0&apos;);</div><div class="line">                &#125;</div><div class="line">                num.push(number);</div><div class="line">            &#125;</div><div class="line">            if(ind&lt;n &amp;&amp; ss[ind]==&apos;[&apos;)&#123;</div><div class="line">                stk.push(sb.toString());</div><div class="line">                sb.setLength(0);</div><div class="line">                ind++;</div><div class="line">            &#125;else if(ind&lt;n &amp;&amp; ss[ind]==&apos;]&apos;)&#123;</div><div class="line">                StringBuilder tmp = new StringBuilder(stk.pop());</div><div class="line">                int repeat = num.pop();</div><div class="line">                while(repeat-- &gt;0)&#123;</div><div class="line">                    tmp.append(sb.toString());</div><div class="line">                &#125;</div><div class="line">                sb=tmp;</div><div class="line">                ind++;</div><div class="line">            &#125;else if(ind&lt;n)</div><div class="line">                sb.append(ss[ind++]);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="636-Exclusive-Time-of-Functions"><a href="#636-Exclusive-Time-of-Functions" class="headerlink" title="636. Exclusive Time of Functions"></a>636. Exclusive Time of Functions</h3><p>思路：遇到start就入栈，如栈的包括id，time，已被使用的时间,主要的难点是递归的话要叠加时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public int[] exclusiveTime(int n, List&lt;String&gt; logs) &#123;</div><div class="line">        int []res =new int[n];</div><div class="line">        Stack&lt;int[]&gt;stk=new Stack&lt;&gt;();//first index is id, second is start time,third is gap</div><div class="line">        int cnt=0;</div><div class="line">        for(String str:logs)&#123;</div><div class="line">            String[]strs=str.split(&quot;:&quot;);</div><div class="line">            if(strs[1].equals(&quot;start&quot;))&#123;</div><div class="line">                stk.push(new int[]&#123;Integer.parseInt(strs[0]),Integer.parseInt(strs[2]),0&#125;);</div><div class="line">            &#125;else if(strs[1].equals(&quot;end&quot;))&#123;</div><div class="line">                int []top=stk.pop();</div><div class="line">                int val = Integer.parseInt(strs[2]);</div><div class="line">                res[top[0]]+=val-top[1]+1-top[2];</div><div class="line">                cnt=val-top[1]+1;</div><div class="line">                if(!stk.isEmpty())</div><div class="line">                    stk.peek()[2]+=cnt;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="331-Verify-Preorder-Serialization-of-a-Binary-Tree"><a href="#331-Verify-Preorder-Serialization-of-a-Binary-Tree" class="headerlink" title="331. Verify Preorder Serialization of a Binary Tree"></a>331. Verify Preorder Serialization of a Binary Tree</h3><p>思路：每遇到两个##就删除，并把之前的变成#。并且要能循环处理这种情况。当然也是可以用入度，出度来做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public boolean isValidSerialization(String preorder) &#123;</div><div class="line">        String[]args=preorder.split(&quot;,&quot;);</div><div class="line">        int n =args.length;</div><div class="line">        Stack&lt;String&gt;stk=new Stack&lt;&gt;();</div><div class="line">        for(int i=0;i&lt;=n;++i)&#123;</div><div class="line">            if(i&lt;n)&#123;</div><div class="line">                if(args[i].equals(&quot;#&quot;) &amp;&amp; !stk.isEmpty() &amp;&amp; stk.peek().equals(&quot;#&quot;))&#123;</div><div class="line">                    stk.pop();</div><div class="line">                    if(stk.isEmpty())</div><div class="line">                        return false;</div><div class="line">                    stk.pop();</div><div class="line">                    stk.push(&quot;#&quot;);</div><div class="line">                &#125;</div><div class="line">                else</div><div class="line">                    stk.push(args[i]);</div><div class="line">            &#125;</div><div class="line">            while(stk.size()&gt;=3)&#123;</div><div class="line">                    if(stk.peek().equals(&quot;#&quot;))&#123;</div><div class="line">                        String top = stk.pop();</div><div class="line">                        if(stk.peek().equals(&quot;#&quot;))&#123;</div><div class="line">                            stk.pop();</div><div class="line">                            stk.pop();</div><div class="line">                            stk.push(&quot;#&quot;);</div><div class="line">                        &#125;else&#123;</div><div class="line">                            stk.push(top);</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    &#125;else</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        return stk.size()==1 &amp;&amp; stk.peek().equals(&quot;#&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">   </div><div class="line"> public boolean isValidSerializationSaveTime(String preorder)&#123;</div><div class="line">        String []args = preorder.split(&quot;,&quot;);</div><div class="line">        int diff=1;</div><div class="line">        for(String c:args)&#123;</div><div class="line">            if(--diff&lt;0)</div><div class="line">                return false;</div><div class="line">            if(!c.equals(&quot;#&quot;))//入度减1，出度加2，但是是#就不加</div><div class="line">                diff+=2;</div><div class="line">        &#125;</div><div class="line">        return diff==0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="456-132-Pattern"><a href="#456-132-Pattern" class="headerlink" title="456 132 Pattern"></a>456 132 Pattern</h3><p>思路：有点像 334. Increasing Triplet Subsequence。注意这种不能简单的用单调栈来解决，单调栈会把数改变。我们要的是小于当前数的最大数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public boolean find132pattern(int[] nums) &#123;</div><div class="line">        Stack&lt;Integer&gt; stk=new Stack&lt;&gt;();</div><div class="line">        int n=nums.length,s3=Integer.MIN_VALUE;</div><div class="line">        for(int i=n-1;i&gt;=0;--i)&#123;</div><div class="line">            if(nums[i]&lt;s3)</div><div class="line">                return true;</div><div class="line">            while(!stk.isEmpty() &amp;&amp; stk.peek()&lt;nums[i])&#123;</div><div class="line">                s3=stk.pop();</div><div class="line">            &#125;</div><div class="line">            stk.push(nums[i]);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="Expectations"><a href="#Expectations" class="headerlink" title="Expectations"></a>Expectations</h1><hr>
<ul>
<li>本来还想修改着简历的，时间太晚了，控制不好工作量</li>
<li>做过的题要及时复习</li>
</ul>
<p><img src="https://lh3.googleusercontent.com/aoeB7MqPXpbyvKM_UPkDlWDRTwTj8jWLBUNGkuy9ThVAYqUc82ZMLrru5Y0NBxgiXHHWP9mvMIpngZfz70c9kxJJ_oUUqdAc3NakwoTezuglU08TkBp7oOwOBZo-kdf3chzPHcgvSA" alt="三番"></p>
<hr>
]]></content>
      
        <categories>
            
            <category> leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[countdown]]></title>
      <url>/2017/07/16/countdown/</url>
      <content type="html"><![CDATA[<h1 id="countdown"><a href="#countdown" class="headerlink" title="countdown"></a>countdown</h1><hr>
<a id="more"></a>
<p>找全职的倒计时已经开始了，希望在接下来的日子里充分利用每一天，用blog来记录每天做了些什么。</p>
<hr>
<p><img src="https://lh3.googleusercontent.com/n21C6qCOZqVhJXgvNou1Iuxr1vlzM_8Nep0r03L-410YfJ3IhPiAW9smN4f29iTZmBI1jE3IOKc-VvbaZcfev-TJIbZP6VJXW_rc0Bk98iknrokLfTtcWMq-0-fmtYtV16DKgFWzaA" alt="加油"></p>
<hr>
]]></content>
      
        <categories>
            
            <category> review </category>
            
        </categories>
        
        
        <tags>
            
            <tag> full-time </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
